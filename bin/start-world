#!/usr/bin/env ruby
# encoding: UTF-8

require 'bundler/setup'
Bundler.require :default

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'

abort "Usage: start-world name" unless ARGV.length == 1
world_name = ARGV.shift

exit 0 if Worlds.running.any? {|w| w[:name] == world_name }

def god_running?
  `bundle exec god status`
  $?.exitstatus == 0
end

def god_load_config config_file
  if god_running?
    `bundle exec god load #{config_file}`
  else
    `bundle exec god -c #{config_file}`
  end
end

def start
  god_load_config god_path
  `bundle exec god start minecraft-#{name}`
end

puts "Starting world #{world_name}"
`#{BIN}/download-server` unless File.exists? JAR

world_path = File.join WORLDS, world_name
properties_path = File.join world_path, "server.properties"

# create world path if it aint there
FileUtils.mkdir_p world_path

# check s3 for world
archived_world = Storage.new.worlds.files.get("#{world_name}.tar.gz")
if archived_world
  FileUtils.mkdir_p "#{ROOT}/backups"
  archive = "#{ROOT}/backups/#{world_name}.tar.gz"
  puts "Retrieved world"
  File.open(archive, "w") do |tar|
    tar.write archived_world.body
  end
  Dir.chdir WORLDS do
    `tar -xzf '#{archive}'`
  end
else
  puts "New world"
end

# symlink server
FileUtils.ln_s JAR, world_path unless File.exist? "#{world_path}/server.jar"

# get a port number to use
port = Worlds.next_available_port

world = World.new world_name, port

# create server.properties
File.open(properties_path, 'w') {|file| file.puts world.server_properties }

# create world.god
template = ERB.new File.read "#{LIB}/world.god.erb"
File.open(world.god_path, 'w') {|file| file.puts template.result(binding) }

# clear server log
server_log = File.join(world_path, "server.log")
File.open(server_log, "w") {|file| file.print }

god_load_config world.god_path
`bundle exec god start minecraft-#{world_name}`

# wait for start
begin
  Timeout::timeout(180) do
    File::Tail::Logfile.open(server_log) do |log|
      log.max_interval = 0.1
      log.interval = 0.1

      log.tail { |line| puts line; raise File::Tail::BreakException if line =~ /Done/ }
    end
  end
rescue File::Tail::BreakException
end