#!/usr/bin/env ruby
# encoding: UTF-8

# This is a WIP

require 'bundler/setup'
Bundler.require :default, :proxy
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'environment'
require 'minefold'
require 'proxy_info_handler'
require 'sauron'
require 'logger'

Thread.abort_on_exception = true
STDOUT.sync = true

DB = MinefoldDb.connection

CONNECTED_PLAYERS = {}
SUPERVISED_WORKERS = {}
SUPERVISED_WORLDS = {}

def worker_in_use? sworker
  SUPERVISED_WORLDS.values.any? {|sworld| sworld.supervised_worker == sworker  }
end

def unused_workers
  SUPERVISED_WORKERS.values.select{|sworker| sworker.running? }.
                            reject{|sworker| worker_in_use? sworker }
end

module EventMachine
  
  module Minefold
    
    module Debugger

      private

      def debug(*data)
        if @debug
          require 'pp'
          pp data
          puts
        end
      end

    end
    
    
    class FindIdleWorkers
      include Deferrable
      include Debugger
      
      def initialize
        begin
          running_workers = Workers.running
          running_workers.each do |w|
            debug "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes} worlds:#{w.worlds.count}"
          end
          idle_workers = running_workers.select{|w| w.worlds.count == 0 }.reject{|w| SUPERVISED_WORKERS.has_key? w.instance_id } 
          succeed idle_workers.sort_by { |w| (w.uptime_minutes % 60) }
        rescue => e
          fail e
        end
      end
    end
    
    class StopWorker
      include Deferrable
      
      def initialize instance_id
        begin
          Workers.get(instance_id).stop!
          succeed
        rescue => e
          fail e
        end
      end
    end
    
    class StartWorld
      include Deferrable
      include Debugger
      
      def initialize world_id
        find_idle_worker = FindIdleWorkers.new
        find_idle_worker.callback do |workers|
          if workers.any?
            # start world
          else
            FindStoppedWorkers.new
          end
        end
      end
    end
    
  end
end

module Client
  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
  end
  
  def info message
    puts "[#{@username||''}@#{@world_id||''}] #{message}"
  end

  def warn message
    puts "[#{@username||''}@#{@world_id||''}] [WARN] #{message}"
  end

  def error message, e
    puts "ERROR: #{e.message}\n#{e.backtrace}"
  end
  
  def get_world_running
    # scenarios:
    #  World is running > connect
    #  World is starting > retry later
    #  World is stopping (backing up) > retry later
    #  World is stopped, worker is starting > retry later
    #  World is stopped, worker is running > start world then connect
    
    #  World not claimed, running worker with no world available > start world then connect
    #  World not claimed, stopped worker available > start worker then retry
    #  World not claimed, no worker available > create new worker then connect
    
    #  Start world on instance failed > stop instance then retry
    
    @supervised_world ||= SUPERVISED_WORLDS[@world_id]
    
    if @supervised_world
      if @supervised_world.running?
        proxy_client
      else
        # world is starting or stopping, attach to deferrable
        @supervised_world.callback { proxy_client @supervised_world }
        EM.add_timer(5) { 
          info "waiting for world:#{@supervised_world}"
          EM.next_tick { get_world_running } 
        }
      end
    else
      # we don't know about this world so we need to get it running
      # no world claimed, we need to claim one so nobody else tries to start this world
      @supervised_world = SUPERVISED_WORLDS[@world_id] = SupervisedWorld.new(:starting)
      
      
      df = EM::Minefold.find_workers
      df.callback { |}
      
    end
      
      
      elsif @supervised_world.state == :stopped && @supervised_world.running_worker?
        # we need to start the world on this worker
        instance_id = @supervised_world.supervised_worker.worker.instance_id
        
        @supervised_world.state = :starting
        info "starting world on #{instance_id}"
        start_world_proc = proc { 
          begin
            @supervised_world.supervised_worker.worker.start_world @world_id 
          rescue => e
            error "Start world error: #{e.message}\n#{e.backtrace.join("\n")}"
            nil
          end
        }
        EM.defer(start_world_proc, proc { |world|
          if world
            @supervised_world.world = world
            @supervised_world.state = :running
            proxy_client
          else
            # world couldn't be started so stop this worker and we'll try again
            info "start world failed on #{instance_id}. Stopping instance"
            stop_current_world
            get_world_running
          end
        })
      else
        # either the world or the worker is still starting up
        info "another player is starting world. Waiting..."
        @wait_for_world ||= EventMachine::PeriodicTimer.new(5) { get_world_running }
      end
    else
      # no world claimed, we need to claim one so nobody else tries to start this world
      @supervised_world = SUPERVISED_WORLDS[@world_id] = SupervisedWorld.new(:stopped)
      # now get the world started
      if supervised_worker = unused_workers.first
        # There is a running worker that isn't being used so lets use it
        info "using running worker #{supervised_worker.worker.instance_id} to start world"
        @supervised_world.supervised_worker = supervised_worker
        EM.next_tick { get_world_running }
      elsif supervised_worker = SUPERVISED_WORKERS.values.find {|sw| sw.stopped? }
        # There is a stopped worker, we'll use that
        @supervised_world.supervised_worker = supervised_worker
        # set it's state to starting so nobody else tries to use it
        supervised_worker.state = :starting
        
        info "starting stopped worker #{supervised_worker.worker.instance_id}"
        EM.defer(proc { supervised_worker.worker.start! }, proc { 
          supervised_worker.state = :running
          info "started stopped worker #{supervised_worker.worker.instance_id}"
          EM.next_tick { get_world_running }
        })
      else
        # no worker available so we'll create a new one
        info "creating new worker"
        EM.defer(proc { Workers.create }, proc { |worker| 
          @supervised_world.supervised_worker = SUPERVISED_WORKERS[worker.instance_id] =
            SupervisedWorker.new(:running, worker)
          info "created new worker #{worker.instance_id}"
          EM.next_tick { get_world_running }
        })
      end
    end
    
    
  end
  
  def proxy_client supervised_world
    host = supervised_world.supervised_worker.worker.public_ip_address
    port = supervised_world.world.port
    @server = EventMachine.connect(host, port, Server) do |server|
      server.plexer = self
      info "proxied to #{host}:#{port}"
    end
    @keepalive.cancel if @keepalive
    @wait_for_world.cancel if @wait_for_world
    
    @credit_muncher = EventMachine::PeriodicTimer.new(60) do
      deduct_minutes 1
    end
    puts "starting credit muncher:#{@credit_muncher}"
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id] << @username unless CONNECTED_PLAYERS[@world_id].include? @username
    info "#{CONNECTED_PLAYERS[@world_id].length} player(s)"
    
    @f_connection_established.succeed
  end

  def receive_data data
    if @username
      @f_connection_established.callback do
        if !@server.error?
          @server.send data
        else
          close_connection
          warn 'unable to connect'
        end
      end
    else
      raw = data.unpack('CN*')
      if raw[0] == 0x02
        # 1 byte for type and 2 bytes for the string length
        raw_offset = 1 + 2

        # Java ecodes strings as UTF-16 and is big-endian by default
        # Way to be different, dude.
        @username = data[raw_offset..-1].force_encoding('UTF-16BE').encode('UTF-8')

        # Lookup username from Mongo
        # TODO: handle mongo failure
        find_user = proc { DB['users'].find_one(:username => @username) }
        EM.defer(find_user, proc { |user|
          @user = user
          unless @user && @user['world_id']
            info "unauthorised player"
            return close_connection
          end
          
          unless @user['credits'] > 0
            info "no credit remaining"
            return close_connection
          end
          
          @user_objectid, @world_id = @user['_id'], @user['world_id'].to_s

          info "connected. #{@user['credits']} credits remaining"

          supervised_world = SUPERVISED_WORLDS[@world_id]

          if supervised_world
            supervised_world.callback { proxy_client supervised_world }
          else
            # no world so keep the client alive while we start one
            @keepalive = EventMachine::PeriodicTimer.new(5) do
              send_data [0].pack('C')
            end
            start_world = EM::Minefold::StartWorld.new @world_id
            start_world.callback { |supervised_world| proxy_client supervised_world }
          end          
          
        })
      end
    end
  end
  
  def send data
    @f_connection_established.callback { send_data data}
  end

  def stop_current_world
    return unless @supervised_world && @supervised_world.supervised_worker
    
    sworker = @supervised_world.supervised_worker
    if @supervised_world.state != :stopping && sworker && sworker.worker
      info "stopping world"
      @supervised_world.state = :stopping
      EM.defer(proc { 
        begin
          sworker.worker.stop_world @world_id
          info "world stopped"
        rescue => e
          error "stopping world:#{@world_id}", e
        end
      }, proc {
        @supervised_world.state = :stopped
      })
      
    end
  end
  
  def deduct_minutes amount
    EM.defer do
      begin
        user = DB['users'].find_and_modify({ 
                      query: {"_id"  => @user_objectid},
                      update:{"$inc" => {"credits"=>-amount }}
                    })
        
        info "deducting 1 credit. #{user['credits']} remaining"

        if user['credits'] <= amount
          EM.next_tick do
            info "disconnecting. 0 minutes remaining"
            close_connection
          end
        end
      rescue => e
        error "error deducting credits", e
      end
    end
  end
  
  # sometimes crashes the client...
  # def send_chat_message message
  #   
  #   data = [0x03].pack('C')
  #   data << [message.size, message.encode('UTF-16BE')].pack("na*")
  #   send_data data
  # end
  
  def unbind
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id].delete @username
    info "client disconnected. #{CONNECTED_PLAYERS[@world_id].length} player(s) in world"
    
    @keepalive.cancel if @keepalive
    @wait_for_world.cancel if @wait_for_world
    puts "stopping credit muncher:#{@credit_muncher}"
    @credit_muncher.cancel if @credit_muncher
    
    if CONNECTED_PLAYERS[@world_id].length == 0
      stop_current_world
    end
  end
end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end

  # TODO: Unbind method. If the server on our end goes down, create a shit
  #       storm.

end

EventMachine.epoll
EventMachine.run do
  def info message
    puts "[INFO] #{message}"
  end
  def warn message
    puts "[WARN] #{message}"
  end

  puts 'collecting initial state'
  
  Workers.existing.each do |worker|
    supervised_worker = SUPERVISED_WORKERS[worker.instance_id] = SupervisedWorker.new(worker.server.state.to_sym, worker)

    worker.worlds.each do |world| 
      # TODO: figure out the state of this world
      SUPERVISED_WORLDS[world.id] = SupervisedWorld.new :running, supervised_worker, world
    end
  end
  
  # listen for minecraft connections
  EventMachine.start_server('0.0.0.0', 25565, Client)
  
  # listen for http connections
  EventMachine::start_server("0.0.0.0", 8081, ProxyInfoHandler)

  find_idle_workers = proc { 
    running_workers = Workers.running
    running_workers.each do |w|
      puts "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes} worlds:#{w.worlds.count}"
    end
    idle_workers = running_workers.select{|w| w.worlds.count == 0 } 
    puts "#{idle_workers.count}/#{running_workers} idle workers"
    idle_workers
  }
  
  idle_killer = EventMachine::PeriodicTimer.new(4 * 60) do 
    # shutdown idle workers
    
    EM.defer(find_idle_workers, proc { |workers|
        workers.select{|w| (w.uptime_minutes % 60) > 55 }.each do |w|
          uptime_minutes = w.uptime_minutes
          instance_id = w.instance_id

          info "Stopping idle worker:#{instance_id} uptime:#{uptime_minutes}"
          
          SUPERVISED_WORKERS[w.instance_id] ||= SupervisedWorker.new(:stopping, w)
          SUPERVISED_WORKERS[w.instance_id].stopping!
          
          df = EM::Minefold::StopWorker.new instance_id
          df.callback {
              info "Stopped idle worker:#{instance_id} uptime:#{uptime_minutes}"
              SUPERVISED_WORKERS.delete instance_id
            }
          df.errback { |e| 
              warn "Failed to stop idle worker:#{instance_id} error:#{e.message}\n#{e.backtrace}"
              SUPERVISED_WORKERS.delete instance_id
            }
        end
    })
  end

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      idle_killer.cancel
      EventMachine.stop
      puts 'terminated'
    end
  end

  puts 'started on 0.0.0.0:25565'
end
