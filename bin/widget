#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'debugger'
require 'widget'
require 'prism/back'

# Usage: widget instance_id host

STDOUT.sync = true
EM.epoll
EM.kqueue = true if EM.kqueue?

INITIAL_PORT = 4000
RUNNING_WORLDS = {}
PID_PATH = File.expand_path "~/tmp/minecraft-server-pids"

module StatusHandler
  def receive_data data
    case data
    when "ping"
      send_data "pong"
    when "worlds"
      send_data RUNNING_WORLDS.to_json
    end
  end
end

module Widget
  class Processor
    include Debugger
    
    attr_reader :stdin_queues, :stop_queues, :instance_id, :host
    attr_reader :requests_key, :redis
    
    def initialize instance_id, host
      @stdin_queues, @stop_queues, @instance_id, @host = {}, {}, instance_id, host
      @requests_key = "workers:#{instance_id}:worlds:requests"
      @redis = Prism.redis
      
      EM.defer method(:gather_initial_state), proc { start_processing }
    end
    
    def gather_initial_state
      FileUtils.mkdir_p PID_PATH
      
      Dir["#{PID_PATH}/*"].each do |pid_file|
        pid = read_pid_file(pid_file)
        if Process.alive? pid
          puts "Found running world:#{pid_file}"
          world_id, port = File.basename(pid_file).split('.')
          port = port.to_i

          Prism.redis.store_running_world instance_id, world_id, host, port
          create_world_in_queues world_id
          watch_world pid_file, instance_id, host, stdin_queues, stop_queues
        else
          puts "Found dead world:#{pid_file}"
          FileUtils.rm_f pid_file
        end
      end
    end
    
    def start_processing
      @stdin_subscription = Prism::PrismRedis.psubscribe "workers:#{instance_id}:worlds:*:stdin", method(:receive_stdin)
      @start_popper = Prism::QueuePopper.new "#{requests_key}:start", method(:receive_start_request)
      @stop_popper  = Prism::QueuePopper.new "#{requests_key}:stop",  method(:receive_stop_request)

      EM.start_server '0.0.0.0', 3000, StatusHandler
      EM.add_periodic_timer(60) { print_status }
      EM.add_periodic_timer(10) { record_stats }

      puts "started #{Fold.env} mode"
    end
    
    def watch_world pid_file
      pid = read_pid_file pid_file
      world_id, port = File.basename(pid_file).split('.')
      port = port.to_i

      RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port }

      world_path = "#{WORLDS}/#{world_id}"
      stdin, stdout = "#{world_path}/world.stdin", "#{world_path}/world.stdout"

      EM.file_tail(stdout, Widget::WorldLineReader) do |reader| 
        world_state = RUNNING_WORLDS[world_id]

        reader.on_line = proc do |line|
          info ["mc", line.type], line.log_entry

          case line.type
          when :chat_message
            Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_id}", line.chat_user, line.chat_message ])
          when :connected_players
            world_state[:players] = Array(line.players)
          when :player_connected
            world_state[:players] = Array(world_state[:players]) | [line.user]
          when :player_disconnected
            world_state[:players] = Array(world_state[:players]) - [line.user]
          when :world_started
            redis.store_running_world instance_id, world_id, host, port
          when :port_taken
            world_watcher.stop_world
          end
        end
      end

      Widget::WorldProcessWatcher.poll pid, stdin, stdout, world_id, instance_id, host, port, stdin_queues, stop_queues do |ww|
        ww.on_process_exit = proc do
          info "process exited. Starting backup"
          redis.hset_hash "worlds:busy", world_id, state:'stopping'
          RUNNING_WORLDS.delete world_id
          @backup_timer.cancel if @backup_timer
          @map_timer.cancel if @map_timer
          stdin_queues.delete world_id
          stop_queues.delete world_id
          FileUtils.rm_f "#{PID_PATH}/#{world_id}.#{port}"

          @backup_waiter = EM.add_periodic_timer(10) do
            unless @backup_in_progress
              @backup_waiter.cancel
              EM.defer(proc { 
                begin
                  Process.waitpid fork { LocalWorld.new(world_id).backup! }
                rescue => e
                  info "ERROR: backup on world stop failed: #{e.message}\n#{e.backtrace}"
                end
                },
                proc { 
                  info "world stop completed  [worlds:busy #{world_id.class} #{world_id}]"
                  redis.hdel "worlds:busy", world_id
                  redis.del "worlds:#{world_id}:connected_players"
                  redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
                })
            end 
          end
        end
      end
    end
    
    def receive_stdin key, channel, message
      puts " â€¢ [#{channel}] #{message}"
      stdin_queue = stdin_queues[channel]
      stdin_queue.push message if stdin_queue
    end
    
    def receive_start_request request
      world_start = JSON.parse request
      world_id = world_start['world_id']
    
      if world = RUNNING_WORLDS[world_id]
        puts "world:#{world_id} is already running"
        redis.store_running_world instance_id, world_id, host, world[:port]
      else
        port = find_available_port
        puts "starting world:#{world_id} process on port:#{port}"

        RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port }

        EM.defer(
          proc { 
            begin
              pid = fork { LocalWorld.prepare world_id, port }
              Process.waitpid pid
              port
            rescue => e
              puts "ERROR: failed to prepare:#{world_id} #{e}"
              nil
            end
          },
          proc { |port|
            begin
              if port
                create_world_in_queues world_id
                
                spawn_world world_id, port, world_start['min_heap_size'], world_start['max_heap_size']
              else
                redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
              end
            rescue => e
              puts "ERROR: failed to spawn minecraft:#{e}"
              redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
            end
        })
      end
    end
    
    def create_world_in_queues world_id
      stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
      stop_queues[world_id] = EM::Queue.new
    end
    
    def find_available_port
      port = INITIAL_PORT + (rand * 10).to_i
      puts "port: #{port} > #{ports_in_use}"
      while ports_in_use.include? port
        port += (rand * 10).to_i
        puts "port: #{port}"
      end
      port
    end
    
    def receive_stop_request world_id
      begin
        if stop_queue = stop_queues[world_id]
          redis.unstore_running_world instance_id, world_id
          stop_queue.push "stop"
      
          stdin_queues.delete "workers:#{instance_id}:worlds:#{world_id}:stdin"
          stop_queues.delete world_id
        else
          redis.hdel "worlds:busy", world_id
          redis.del "worlds:#{world_id}:connected_players"
          redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
          puts "world:#{world_id} stop request recieved but world is not running here"
        end
      rescue => e
        redis.hdel "worlds:busy", world_id
        puts "ERROR: failed to stop world:#{e}"
      end
    end
    
    def spawn_world world_id, port, min_heap_size, max_heap_size
      world_path = "#{WORLDS}/#{world_id}"
      pid_file = "#{PID_PATH}/#{world_id}.#{port}"
      cmd = "java -Xmx#{max_heap_size}M -Xms#{min_heap_size}M -jar server.jar nogui"

      Pot.spawn_pot_process world_path, pid_file, cmd, "world.stdin", "world.stdout", "world.stdout" do
        watch_world pid_file
      end
    end
    
    def world_count
      RUNNING_WORLDS.size
    end
    
    def player_count
      RUNNING_WORLDS.inject(0) { |sum, (id, w)| sum + (w[:players] || []).size }
    end
    
    def print_status
      m = System.memory_usage

      puts "worlds:#{world_count} players:#{player_count} mem:#{"%.0f%" % (m[:used]/m[:total].to_f * 100)} total:#{m[:total]} used:#{m[:used]} per_player:#{player_count > 0 ? m[:used]/player_count : 'no_players'} per_world:#{world_count > 0 ? m[:used]/world_count : 'no_worlds'}"
    end
    
    def record_stats
      StatsD.measure "boxes.#{instance_id}.worlds.count", world_count
      StatsD.measure "boxes.#{instance_id}.players.count", player_count
    end
    
    def read_pid_file pid_file
      File.exists?(pid_file) && File.read(pid_file).strip.to_i
    end

    def world_running? world_id
      pid_file = Dir["#{PID_PATH}/*"].find{|f| File.basename(f.split('.').first) == world_id }
      pid = read_pid_file
      Process.alive? pid
    end

    def ports_in_use
      RUNNING_WORLDS.values.map{|world| world[:port] }
    end
    
  end
  
  EM.run do
    instance_id = ARGV.shift || ENV['INSTANCE_ID']
           host = ARGV.shift || ENV['INSTANCE_IP']

    raise "specify INSTANCE_ID and INSTANCE_IP" unless instance_id && host
    
    Processor.new instance_id, host
  end
end