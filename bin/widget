#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default

require 'tmpdir'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'widget'
require 'eventmachine/popen3'
require 'prism/back'

# Usage: widget instance_id host

instance_id = ARGV.shift || ENV['INSTANCE_ID']
       host = ARGV.shift || ENV['INSTANCE_IP']

STDOUT.sync = true
EM.epoll

INITIAL_PORT = 4000
RUNNING_WORLDS = {}

PID_PATH = "#{Dir.tmpdir}/minecraft-server-pids"

module Enumerable
  def strip_blanks
    reject {|i| i.nil? || i.empty? }
  end
end

class WorldWatcher < EventMachine::Connection 
  include Resque::Helpers
  
  attr_reader :world_id, :instance_id, :host, :port, :redis, :state, :stdin_queue
  
  def initialize world_id, instance_id, host, port, stdin_queue, stop_queue
    @world_id, @instance_id, @host, @port = world_id, instance_id, host, port
    @world_ready = false
    @redis = Prism.redis
    @line_channel = EM::Channel.new
    @state = state
    @stdin_queue = stdin_queue

    RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port, players:[] }
    @world_state = RUNNING_WORLDS[world_id]
    
    process_stdin
    stop_queue.pop { stop_world }
  end
  
  def info tag, message = nil
    tag_parts = [world_id]
    tag_parts += Array(tag) if tag
    tag_string = tag_parts.flatten.strip_blanks.join('|')
    puts "[#{tag_string}] #{message}"
  end
  
  
  def write_pid
    pid_file = "#{PID_PATH}/#{get_pid}" 
    File.open(pid_file, "w") {|f| f.print get_pid }
    pid_file
  end
  
  def post_init
    @backup_timer = EM.add_periodic_timer(10 * 60) { backup_world }
       @map_timer = EM.add_periodic_timer(10 * 60) { Resque.enqueue Job::MapWorld, world_id }
  end
  
  def receive_data data
    data.split("\n").map{|l| LogLine.new l }.each do |line|
      if !@world_ready && line.type == :world_started
        @world_ready = true
        world_ready 
      end
      
      info ["mc", line.type], line.log_entry
      
      case line.type
      when :chat_message
        world_chat line
      when :player_connected
        @world_state[:players] = @world_state[:players] | [line.user]
      when :player_disconnected
        @world_state[:players] = @world_state[:players] - [line.user]
      end
      
      @line_channel.push line
    end
  end
  
  def receive_stderr data 
    receive_data data
  end
  
  def world_ready
    redis.hset_hash "worlds:running", world_id, instance_id:instance_id, host:host, port:port
    redis.hdel "worlds:busy", world_id
    redis.publish_json "worlds:requests:start:#{world_id}", instance_id:instance_id, host:host, port:port
  end
  
  def world_objectid
    BSON::ObjectId(world_id)
  end
  
  def world_chat line
    Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_objectid}", line.chat_user, line.chat_message ])
  end
  
  def stop_world
    send_line "stop"
  end
  
  def send_line line
    send_data "#{line}\n"
  end
  
  def unbind
    info "process exited. Starting backup"
    RUNNING_WORLDS.delete world_id
    @backup_timer.cancel if @backup_timer
    @map_timer.cancel if @map_timer
    
    @backup_waiter = EM.add_periodic_timer(10) do
      unless @backup_in_progress
        @backup_waiter.cancel
        EM.defer(proc { 
          begin
            LocalWorld.new(world_id).backup!
          rescue => e
            info "ERROR: backup on world stop failed: #{e.message}\n#{e.backtrace}"
          end
          },
          proc { 
            redis.hdel "worlds:busy", world_id
            redis.del "worlds:#{world_id}:connected_players"
            redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
          })
      end 
    end
  end
  
  def backup_world
    @backup_in_progress = true
    info "starting backup"
    send_line "save-off"
    send_line "save-all"
    EM.add_timer 3 do
      EM.defer(
        proc { 
          begin
            LocalWorld.new(world_id).backup! 
          rescue => e
            info "ERROR: backup failed: #{e.message}\n#{e.backtrace}"
          end
          }, 
        proc { 
          send_line "save-on"
          @backup_in_progress = false
        })
    end
  end
  
  def process_stdin
    stdin_queue.pop { |message| send_line message; EM.next_tick { process_stdin } }
  end
  
end

module StatusHandler
  def receive_data data
    case data
    when "ping"
      send_data "pong"
    when "worlds"
      send_data RUNNING_WORLDS.to_json
    end
  end
end

def start_processing instance_id, host
  redis = Prism.redis

  stdin_queues = {}
  stop_queues = {}
  
  subscription = Prism::PrismRedis.connect
  subscription.psubscribe "workers:#{instance_id}:worlds:*:stdin"
  subscription.on :pmessage do |key, channel, message|
    puts " â€¢ [#{channel}] #{message}"
    stdin_queue = stdin_queues[channel]
    stdin_queue.push message if stdin_queue
  end
  
  requests = "workers:#{instance_id}:worlds:requests"
  
  start_popper = Prism::QueuePopper.new "#{requests}:start"
  start_popper.on_pop do |request|
    world_start = JSON.parse request
    world_id = world_start['world_id']
    
    port = INITIAL_PORT + RUNNING_WORLDS.size + (rand * 100).to_i
    puts "starting world:#{world_id} process on port:#{port}"

    EM.defer(
      proc { 
        begin
          LocalWorld.prepare world_id, port
          true
        rescue => e
          puts "ERROR: failed to prepare:#{world_id} #{e}"
          false
        end
      },
      proc { |succeeded|
        begin
          if succeeded
            stdin_queue = stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
            stop_queue = stop_queues[world_id] = EM::Queue.new

            Dir.chdir("#{ROOT}/worlds/#{world_id}") do
              connection = EM.popen3 "java -Xmx#{world_start['max_heap_size']}M -Xms#{world_start['min_heap_size']}M -jar server.jar nogui", WorldWatcher, world_id, instance_id, host, port, stdin_queue, stop_queue
            end
            start_popper.listen
          else
            redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
          end
        rescue => e
          puts "ERROR: failed to spawn minecraft:#{e}"
          redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
        end
    })
  end  
  
  stop_popper = Prism::QueuePopper.new "#{requests}:stop"
  stop_popper.on_pop do |world_id|
    begin
      if stop_queue = stop_queues[world_id]
        redis.hdel "worlds:running", world_id
        stop_queue.push "stop"
      
        stdin_queues.delete "workers:#{instance_id}:worlds:#{world_id}:stdin"
        stop_queues.delete world_id
      else
        puts "world:#{world_id} stop request recieved but world is not running here"
      end
    rescue => e
      puts "ERROR: failed to stop world:#{e}"
    end
  end
  
  # maintenance_popper = Prism::QueuePopper.new "#{request}"

  EM.start_server '0.0.0.0', 3000, StatusHandler
  
  %W[INT TERM].each do |sig| 
    Signal.trap(sig) { EM.stop }
  end
  
  puts "started #{Fold.env} mode"
end

EM.run do
  FileUtils.mkdir_p PID_PATH
  
  EM.defer(proc {
      Dir["#{PID_PATH}/*"].each do |pid_file|
        File.open(pid_file, "r") do |f|
          pid = f.read.strip.to_i
          puts "Killing #{pid}"
          Process.kill "TERM", pid unless pid == 0 rescue nil
          FileUtils.rm_f pid_file
          
          # if Dir.exists? 
          #   LocalWorld.new(world_id).backup!
          # end
        end
      end
    }, 
    proc {
      start_processing instance_id, host
    })
end