#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'widget'
require 'eventmachine/popen3'
require 'prism/back'

# Usage: widget instance_id host

instance_id = ARGV.shift || ENV['INSTANCE_ID']
       host = ARGV.shift || ENV['INSTANCE_IP']

STDOUT.sync = true
EM.epoll

INITIAL_PORT = 4000
RUNNING_WORLDS = {}

class WorldWatcher < EventMachine::Connection 
  include Resque::Helpers
  
  attr_reader :world_id, :instance_id, :host, :port, :redis
  
  def initialize world_id, instance_id, host, port, stdin_queue, stop_queue
    @world_id, @instance_id, @host, @port = world_id, instance_id, host, port
    @world_ready = false
    @redis = Prism.redis
    @line_channel = EM::Channel.new
    
    stdin_queue.pop { |message| send_line message }
    stop_queue.pop { stop_world }
  end
  
  def post_init
    RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port }
    
    @backup_timer = EM.add_periodic_timer(10 * 60) { backup_world }
    @map_timer = EM.add_periodic_timer(10 * 60) { Resque.enqueue(Job::MapWorld, world_id) }
  end
  
  def receive_data data
    puts data
  end
  
  def receive_stderr data 
    puts data
    data.split("\n").map{|l| LogLine.new l }.each do |line|
      if !@world_ready && line.world_started?
        @world_ready = true
        world_ready 
      end
      
      world_chat line if line.chat_user
      
      @line_channel.push line
    end
  end
  
  def world_ready
    puts "world:#{world_id} ready"
    redis.hdel "worlds:busy", world_id
    redis.hset_hash "worlds:running", world_id, instance_id:instance_id, host:host, port:port
    redis.publish_json "worlds:requests:start:#{world_id}", instance_id:instance_id, host:host, port:port
  end
  
  def world_objectid
    BSON::ObjectId(world_id)
  end
  
  def world_chat line
    Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_objectid}", line.chat_user, line.chat_message ])
    
    puts "[#{line.chat_user}] #{line.chat_message}"
  end
  
  def stop_world
    send_line "stop"
  end
  
  def send_line line
    send_data "#{line}\n"
  end
  
  def unbind
    puts "world:#{world_id} quit. Starting backup"
    RUNNING_WORLDS.delete world_id
    @backup_timer.cancel if @backup_timer
    @map_timer.cancel if @map_timer 
    
    @backup_waiter = EM.add_periodic_timer(1) do
      unless @backup_in_progress
        @backup_waiter.cancel
        EM.defer(proc { LocalWorld.new(world_id).backup! }, 
          proc { 
            redis.hdel "worlds:busy", world_id
            redis.del "worlds:#{world_id}:connected_players"
            redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
          })
      end 
    end
  end
  
  def backup_world
    @backup_in_progress = true
    puts "starting backup:#{world_id}"
    send_line "save-off"
    send_line "save-all"
    EM.add_timer 3 do
      EM.defer(
        proc { LocalWorld.new(world_id).backup! }, 
        proc { 
          send_line "save-on"
          @backup_in_progress = false
        })
    end
  end
end

module StatusHandler
  def receive_data data
    case data
    when "ping"
      send_data "pong"
    when "worlds"
      send_data RUNNING_WORLDS.to_json
    end
  end
end


EM.run do
  redis = Prism.redis

  stdin_queues = {}
  stop_queues = {}
  
  subscription = Prism::PrismRedis.connect
  subscription.psubscribe "workers:#{instance_id}:worlds:*:stdin"
  subscription.on :pmessage do |key, channel, message|
    puts " â€¢ [#{channel}] #{message}"
    stdin_queue = stdin_queues[channel]
    stdin_queue.push message if stdin_queue
  end
  
  requests = "workers:#{instance_id}:worlds:requests"
  
  start_popper = Prism::QueuePopper.new "#{requests}:start"
  start_popper.on_pop do |request|
    world_start = JSON.parse request
    world_id = world_start['world_id']
    
    op = redis.hexists "worlds:busy", world_id
    op.callback do |busy|
      if busy == 1
        puts "world:#{world_id} is busy ignoring start request"
      else
        redis.hset_hash "worlds:busy", world_id, state:'starting'

        port = INITIAL_PORT + RUNNING_WORLDS.size
        puts "starting world:#{world_id} on port:#{port}"

        EM.defer(
          proc { 
            begin
              LocalWorld.prepare world_id, port
              true
            rescue => e
              puts "ERROR: failed to prepare:#{world_id}"
              false
            end
          },
          proc { |succeeded|
            if succeeded
              stdin_queue = stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
              stop_queue = stop_queues[world_id] = EM::Queue.new

              Dir.chdir("worlds/#{world_id}") do
                EM.popen3 "java -Xmx#{world_start['max_heap_size']}M -Xms#{world_start['min_heap_size']}M -jar server.jar nogui",
                          WorldWatcher, world_id, instance_id, host, port, stdin_queue, stop_queue
              end
              start_popper.listen
            else
              redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
            end
        })
      end
    end
  end  
  
  stop_popper = Prism::QueuePopper.new "#{requests}:stop"
  stop_popper.on_pop do |world_id|
    if stop_queue = stop_queues[world_id]
      redis.hset_hash "worlds:busy", world_id, state:'stopping'
      redis.hdel "worlds:running", world_id
      stop_queue.push "stop"
      
      stdin_queues.delete "workers:#{instance_id}:worlds:#{world_id}:stdin"
      stop_queues.delete world_id
    else
      puts "world:#{world_id} stop request recieved but world is not running here"
    end
  end

  EM.start_server '0.0.0.0', 3000, StatusHandler
  
  %W[INT TERM].each do |sig| 
    Signal.trap(sig) { EM.stop }
  end
  
  puts "started #{Fold.env} mode"
end