#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default

require 'tmpdir'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'widget'
require 'eventmachine/popen3'
require 'prism/back'

# Usage: widget instance_id host

instance_id = ARGV.shift || ENV['INSTANCE_ID']
       host = ARGV.shift || ENV['INSTANCE_IP']

STDOUT.sync = true
EM.epoll

INITIAL_PORT = 4000
RUNNING_WORLDS = {}

module Enumerable
  def strip_blanks
    reject {|i| i.nil? || i.empty? }
  end
end

module Process
  def self.alive?(pid)
    begin
      Process.kill(0, pid)
      true
    rescue Errno::ESRCH
      false
    end
  end
end

module WorldWatcher
  include Resque::Helpers
  
  attr_reader :world_id, :instance_id, :host, :port, :redis, :state, :stdin_queue, :pid_file
  
  def initialize world_id, instance_id, host, port, stdin_queue, stop_queue
    @world_id, @instance_id, @host, @port = world_id, instance_id, host, port
    @world_ready = false
    @redis = Prism.redis
    @line_channel = EM::Channel.new
    @state = state
    @stdin_queue = stdin_queue

    RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port, players:[] }
    @world_state = RUNNING_WORLDS[world_id]
    
    process_stdin
    stop_queue.pop { stop_world }
  end
  
  def info tag, message = nil
    tag_parts = [world_id]
    tag_parts += Array(tag) if tag
    tag_string = tag_parts.flatten.strip_blanks.join('|')
    puts "[#{tag_string}] #{message}"
  end
  
  def post_init
    EM.file_tail stdout do |ft, line|
      receive_data line
    end
    
    @backup_timer = EM.add_periodic_timer(10 * 60) { backup_world }
       @map_timer = EM.add_periodic_timer(10 * 60) { Resque.enqueue Job::MapWorld, world_id }
  end
  
  def receive_data data
    data.split("\n").map{|l| LogLine.new l }.each do |line|
      if !@world_ready && line.type == :world_started
        @world_ready = true
        world_ready 
      end
      
      info ["mc", line.type], line.log_entry
      
      case line.type
      when :chat_message
        world_chat line
      when :player_connected
        @world_state[:players] = @world_state[:players] | [line.user]
      when :player_disconnected
        @world_state[:players] = @world_state[:players] - [line.user]
      end
      
      @line_channel.push line
    end
  end
  
  def world_ready
    redis.hset_hash "worlds:running", world_id, instance_id:instance_id, host:host, port:port
    redis.hdel "worlds:busy", world_id
    redis.publish_json "worlds:requests:start:#{world_id}", instance_id:instance_id, host:host, port:port
  end
  
  def world_objectid
    BSON::ObjectId(world_id)
  end
  
  def world_chat line
    Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_objectid}", line.chat_user, line.chat_message ])
  end
  
  def stop_world
    send_line "stop"
  end
  
  def send_line line
    send_data "#{line}\n"
  end
  
  def unbind
    info "process exited. Starting backup"
    RUNNING_WORLDS.delete world_id
    @backup_timer.cancel if @backup_timer
    @map_timer.cancel if @map_timer
    
    @backup_waiter = EM.add_periodic_timer(10) do
      unless @backup_in_progress
        @backup_waiter.cancel
        EM.defer(proc { 
          begin
            LocalWorld.new(world_id).backup!
          rescue => e
            info "ERROR: backup on world stop failed: #{e.message}\n#{e.backtrace}"
          end
          },
          proc { 
            redis.hdel "worlds:busy", world_id
            redis.del "worlds:#{world_id}:connected_players"
            redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
          })
      end 
    end
  end
  
  def backup_world
    @backup_in_progress = true
    info "starting backup"
    send_line "save-off"
    send_line "save-all"
    EM.add_timer 3 do
      EM.defer(
        proc { 
          begin
            LocalWorld.new(world_id).backup! 
          rescue => e
            info "ERROR: backup failed: #{e.message}\n#{e.backtrace}"
          end
          }, 
        proc { 
          send_line "save-on"
          @backup_in_progress = false
        })
    end
  end
  
  def process_stdin
    stdin_queue.pop { |message| send_line message; EM.next_tick { process_stdin } }
  end
  
end

module StatusHandler
  def receive_data data
    case data
    when "ping"
      send_data "pong"
    when "worlds"
      send_data RUNNING_WORLDS.to_json
    end
  end
end

def memory_usage
  `which free`
  if $?.exitstatus == 0
    parts = `free -m`.split
    { total:parts[7].to_i, used:parts[8].to_i }
  else
    { total:4096, used:1024 }
  end
end

def start_processing instance_id, host
  redis = Prism.redis

  stdin_queues = {}
  stop_queues = {}
  
  subscription = Prism::PrismRedis.connect
  subscription.psubscribe "workers:#{instance_id}:worlds:*:stdin"
  subscription.on :pmessage do |key, channel, message|
    puts " â€¢ [#{channel}] #{message}"
    stdin_queue = stdin_queues[channel]
    stdin_queue.push message if stdin_queue
  end
  
  requests = "workers:#{instance_id}:worlds:requests"
  
  start_popper = Prism::QueuePopper.new "#{requests}:start"
  start_popper.on_pop do |request|
    world_start = JSON.parse request
    world_id = world_start['world_id']
    
    port = INITIAL_PORT + RUNNING_WORLDS.size + (rand * 100).to_i
    puts "starting world:#{world_id} process on port:#{port}"

    EM.defer(
      proc { 
        begin
          LocalWorld.prepare world_id, port
          true
        rescue => e
          puts "ERROR: failed to prepare:#{world_id} #{e}"
          false
        end
      },
      proc { |succeeded|
        begin
          if succeeded
            stdin_queue = stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
            stop_queue = stop_queues[world_id] = EM::Queue.new

            spawn_world world_id
            start_popper.listen
          else
            redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
          end
        rescue => e
          puts "ERROR: failed to spawn minecraft:#{e}"
          redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
        end
    })
  end  
  
  stop_popper = Prism::QueuePopper.new "#{requests}:stop"
  stop_popper.on_pop do |world_id|
    begin
      if stop_queue = stop_queues[world_id]
        redis.hdel "worlds:running", world_id
        stop_queue.push "stop"
      
        stdin_queues.delete "workers:#{instance_id}:worlds:#{world_id}:stdin"
        stop_queues.delete world_id
      else
        puts "world:#{world_id} stop request recieved but world is not running here"
      end
    rescue => e
      puts "ERROR: failed to stop world:#{e}"
    end
  end
  
  EM.add_periodic_timer 60 do
    m = memory_usage
    world_count  = RUNNING_WORLDS.size
    player_count = RUNNING_WORLDS.inject(0) { |sum, (id, w)| sum + w[:players].size }
    
    puts "worlds:#{world_count} players:#{player_count} mem:#{"%.0f%" % (m[:used]/m[:total].to_f * 100)} total:#{m[:total]} used:#{m[:used]} per_player:#{player_count > 0 ? m[:used]/player_count : 'no_players'} per_world:#{world_count > 0 ? m[:used]/world_count : 'no_worlds'}"
  end

  EM.start_server '0.0.0.0', 3000, StatusHandler
  
  %W[INT TERM].each do |sig| 
    Signal.trap(sig) { EM.stop }
  end
  
  puts "started #{Fold.env} mode"
end



def spawn_detached dir, cmd
  process = fork do
    Dir.chdir dir
    exec cmd
  end
  Process.detach process
end

def spawn_world world_id
  world_path = "#{WORLDS}/#{world_id}"
  pid_file = "#{PID_PATH}/#{world_id}"
  
  FileUtils.mkdir_p PID_PATH
  spawn_detached world_path, "#{BIN}/pot world.stdin world.stdout world.stdout #{pid_file} java -Xmx1024M -Xms512M -jar server.jar nogui"
  
  file_wait_timer = EM.add_periodic_timer(0.1) do
    if File.exist? pid_file
      file_wait_timer.cancel
      puts "pot started:#{pid_file}"
      
      watch_world pid_file
    end
  end
end

def world_running? world_id
  pid_file = "#{PID_PATH}/#{world_id}"
  if File.exists? pid_file
    pid = File.read(pid_file).strip.to_i
    Process.alive? pid
  end
end

def watch_world pid_file
  pid = read_pid_file pid_file
  world_id = File.basename pid_file
  EM.watch_process pid, WorldWatcher, world_id, "#{WORLDS}/#{world_id}/world.stdout"
end

def read_pid_file pid_file
  File.exists?(pid_file) && File.read(pid_file).strip.to_i
end

PID_PATH = "#{ROOT}/tmp/minecraft-server-pids"

EM.kqueue = true if EM.kqueue?

EM.run do
  FileUtils.mkdir_p PID_PATH
  
  EM.defer(proc {
    Dir["#{PID_PATH}/*"].each do |pid_file|
      pid = read_pid_file(pid_file)
      if Process.alive? pid
        puts "Found running world:#{pid_file}"
        watch_world pid_file
      else
        puts "Found dead world:#{pid_file}"
        FileUtils.rm_f pid_file
      end
    end
    
    }, proc { start_processing instance_id, host })
end