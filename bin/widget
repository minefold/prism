#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'widget'
require 'prism/back'

# Usage: widget instance_id host

instance_id = ARGV.shift || ENV['INSTANCE_ID']
       host = ARGV.shift || ENV['INSTANCE_IP']

STDOUT.sync = true
EM.epoll
EM.kqueue = true if EM.kqueue?

INITIAL_PORT = 4000
RUNNING_WORLDS = {}

module Enumerable
  def strip_blanks
    reject {|i| i.nil? || i.empty? }
  end
end

module Process
  def self.alive?(pid)
    begin
      Process.kill(0, pid)
      true
    rescue Errno::ESRCH
      false
    end
  end
end

class WorldStdoutReader < EventMachine::FileTail
  attr_reader :redis
  attr_accessor :world_id, :world_state, :instance_id, :host, :port
  
  def info tag, message = nil
    tag_parts = [world_id]
    tag_parts += Array(tag) if tag
    tag_string = tag_parts.flatten.strip_blanks.join('|')
    puts "[#{tag_string}] #{message}"
  end
  
  def initialize(path, startpos=-1)
    super(path, startpos)
    @redis = Prism.redis
    yield self if block_given?
  end

  def receive_data(data)
    data.split("\n").each {|line| receive_line LogLine.new line }
  end
  
  def receive_line line
    if !@world_ready && line.type == :world_started
      @world_ready = true
      world_ready 
    end
    
    info ["mc", line.type], line.log_entry
    
    case line.type
    when :chat_message
      world_chat line
    when :player_connected
      world_state[:players] = world_state[:players] | [line.user]
    when :player_disconnected
      world_state[:players] = world_state[:players] - [line.user]
    end
  end
  
  def world_ready
    redis.hset_hash "worlds:running", world_id, instance_id:instance_id, host:host, port:port
    redis.hdel "worlds:busy", world_id
    redis.publish_json "worlds:requests:start:#{world_id}", instance_id:instance_id, host:host, port:port
  end
  
  def world_chat line
    Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_id}", line.chat_user, line.chat_message ])
  end
end

module WorldWatcher
  include Resque::Helpers
  
  attr_reader :stdin, :stdout, :world_id, :instance_id, :host, :port, :redis, :state, :stdin_queue
  
  def initialize stdin, stdout, world_id, instance_id, host, port, stdin_queue, stop_queue
    @stdin, @stdout = stdin, stdout
    @world_id, @instance_id, @host, @port = world_id, instance_id, host, port
    @redis = Prism.redis
    @state = state
    @stdin_queue = stdin_queue

    RUNNING_WORLDS[world_id] = { instance_id: instance_id, host:host, port:port, players:[] }
    
    process_stdin
    stop_queue.pop { stop_world }
  end
  
  def info tag, message = nil
    tag_parts = [world_id]
    tag_parts += Array(tag) if tag
    tag_string = tag_parts.flatten.strip_blanks.join('|')
    puts "[#{tag_string}] #{message}"
  end
  
  def post_init
    EM.file_tail(stdout, WorldStdoutReader) do |reader| 
      reader.world_id = world_id
      reader.world_state = RUNNING_WORLDS[world_id]
      reader.instance_id = instance_id
      reader.host = host
      reader.port = port
    end
    
    @backup_timer = EM.add_periodic_timer(10 * 60) { backup_world }
       @map_timer = EM.add_periodic_timer(10 * 60) { Resque.enqueue Job::MapWorld, world_id }
  end
    
  def stop_world
    send_line "stop"
  end
  
  def send_line line
    File.open(stdin, 'a') {|f| f.puts line }
  end
  
  def unbind
    info "process exited. Starting backup"
    RUNNING_WORLDS.delete world_id
    @backup_timer.cancel if @backup_timer
    @map_timer.cancel if @map_timer
    
    @backup_waiter = EM.add_periodic_timer(10) do
      unless @backup_in_progress
        @backup_waiter.cancel
        EM.defer(proc { 
          begin
            pid = fork { LocalWorld.new(world_id).backup! }
            Process.waitpid pid
          rescue => e
            info "ERROR: backup on world stop failed: #{e.message}\n#{e.backtrace}"
          end
          },
          proc { 
            redis.hdel "worlds:busy", world_id
            redis.del "worlds:#{world_id}:connected_players"
            redis.publish_json "worlds:requests:stop:#{world_id}", world_id:world_id, instance_id:instance_id
          })
      end 
    end
  end
  
  def backup_world
    @backup_in_progress = true
    info "starting backup"
    send_line "save-off"
    send_line "save-all"
    EM.add_timer 3 do
      EM.defer(
        proc { 
          begin
            LocalWorld.new(world_id).backup! 
          rescue => e
            info "ERROR: backup failed: #{e.message}\n#{e.backtrace}"
          end
          }, 
        proc { 
          send_line "save-on"
          @backup_in_progress = false
        })
    end
  end
  
  def process_stdin
    stdin_queue.pop { |message| send_line message; EM.next_tick { process_stdin } }
  end
  
end

module StatusHandler
  def receive_data data
    case data
    when "ping"
      send_data "pong"
    when "worlds"
      send_data RUNNING_WORLDS.to_json
    end
  end
end

def memory_usage
  `which free`
  if $?.exitstatus == 0
    parts = `free -m`.split
    { total:parts[7].to_i, used:parts[8].to_i }
  else
    { total:4096, used:1024 }
  end
end

def start_processing stdin_queues, stop_queues, instance_id, host
  redis = Prism.redis

  subscription = Prism::PrismRedis.connect
  subscription.psubscribe "workers:#{instance_id}:worlds:*:stdin"
  subscription.on :pmessage do |key, channel, message|
    puts " â€¢ [#{channel}] #{message}"
    stdin_queue = stdin_queues[channel]
    stdin_queue.push message if stdin_queue
  end
  
  requests = "workers:#{instance_id}:worlds:requests"
  
  start_popper = Prism::QueuePopper.new "#{requests}:start"
  start_popper.on_pop do |request|
    world_start = JSON.parse request
    world_id = world_start['world_id']
    
    if world = RUNNING_WORLDS[world_id]
      puts "world:#{world_id} is already running"
      redis.hset_hash "worlds:running", world_id, instance_id:instance_id, host:host, port:world[:port]
      redis.hdel "worlds:busy", world_id
      redis.publish_json "worlds:requests:start:#{world_id}", instance_id:instance_id, host:host, port:world[:port]
    else
      port = INITIAL_PORT + RUNNING_WORLDS.size + (rand * 100).to_i
      puts "starting world:#{world_id} process on port:#{port}"

      EM.defer(
        proc { 
          begin
            pid = fork { LocalWorld.prepare world_id, port }
            Process.waitpid pid
            true
          rescue => e
            puts "ERROR: failed to prepare:#{world_id} #{e}"
            false
          end
        },
        proc { |succeeded|
          begin
            if succeeded
              stdin_queue = stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
              stop_queue = stop_queues[world_id] = EM::Queue.new

              spawn_world world_id, instance_id, host, port, stdin_queue, stop_queue
              start_popper.listen
            else
              redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
            end
          rescue => e
            puts "ERROR: failed to spawn minecraft:#{e}"
            redis.publish_json "worlds:requests:start:#{world_id}", failed:'prepare_world'
          end
      })
    end
  end  
  
  stop_popper = Prism::QueuePopper.new "#{requests}:stop"
  stop_popper.on_pop do |world_id|
    begin
      if stop_queue = stop_queues[world_id]
        redis.hdel "worlds:running", world_id
        stop_queue.push "stop"
      
        stdin_queues.delete "workers:#{instance_id}:worlds:#{world_id}:stdin"
        stop_queues.delete world_id
      else
        puts "world:#{world_id} stop request recieved but world is not running here"
      end
    rescue => e
      puts "ERROR: failed to stop world:#{e}"
    end
  end
  
  EM.add_periodic_timer 60 do
    m = memory_usage
    world_count  = RUNNING_WORLDS.size
    player_count = RUNNING_WORLDS.inject(0) { |sum, (id, w)| sum + w[:players].size }
    
    puts "worlds:#{world_count} players:#{player_count} mem:#{"%.0f%" % (m[:used]/m[:total].to_f * 100)} total:#{m[:total]} used:#{m[:used]} per_player:#{player_count > 0 ? m[:used]/player_count : 'no_players'} per_world:#{world_count > 0 ? m[:used]/world_count : 'no_worlds'}"
  end

  EM.start_server '0.0.0.0', 3000, StatusHandler
  
  %W[INT TERM].each do |sig| 
    Signal.trap(sig) { EM.stop }
  end
  
  puts "started #{Fold.env} mode"
end

def spawn_detached dir, cmd
  process = fork do
    Dir.chdir dir
    exec cmd
  end
  Process.detach process
end

def spawn_world world_id, instance_id, host, port, stdin_queue, stop_queue
  world_path = "#{WORLDS}/#{world_id}"
  pid_file = "#{PID_PATH}/#{world_id}.#{port}"
  
  FileUtils.mkdir_p PID_PATH
  spawn_detached world_path, "#{BIN}/pot world.stdin world.stdout world.stdout #{pid_file} java -Xmx1024M -Xms512M -jar server.jar nogui"
  
  file_wait_timer = EM.add_periodic_timer(0.1) do
    if File.exist? pid_file
      file_wait_timer.cancel
      puts "pot started:#{pid_file}"
      
      watch_world pid_file, instance_id, host, stdin_queue, stop_queue
    end
  end
end

def watch_world pid_file, instance_id, host, stdin_queue, stop_queue
  pid = read_pid_file pid_file
  world_id, port = File.basename(pid_file).split('.')
  world_path = "#{WORLDS}/#{world_id}"
  stdin, stdout = "#{world_path}/world.stdin", "#{world_path}/world.stdout"
  EM.watch_process pid, WorldWatcher, stdin, stdout, world_id, instance_id, host, port, stdin_queue, stop_queue
end

def read_pid_file pid_file
  File.exists?(pid_file) && File.read(pid_file).strip.to_i
end

PID_PATH = "#{ROOT}/tmp/minecraft-server-pids"

def world_running? world_id
  pid_file = Dir["#{PID_PATH}/*"].find{|f| File.basename(f.split('.').first) == world_id }
  pid = read_pid_file
  Process.alive? pid
end

stdin_queues = {}
stop_queues = {}

EM.run do
  FileUtils.mkdir_p PID_PATH
  
  EM.defer(proc {
    Dir["#{PID_PATH}/*"].each do |pid_file|
      pid = read_pid_file(pid_file)
      if Process.alive? pid
        puts "Found running world:#{pid_file}"
        world_id, port = File.basename(pid_file).split('.')
        stdin_queue = stdin_queues["workers:#{instance_id}:worlds:#{world_id}:stdin"] = EM::Queue.new
        stop_queue = stop_queues[world_id] = EM::Queue.new
        
        watch_world pid_file, instance_id, host, stdin_queue, stop_queue
      else
        puts "Found dead world:#{pid_file}"
        FileUtils.rm_f pid_file
      end
    end
    
    }, proc { start_processing stdin_queues, stop_queues, instance_id, host })
    
  EM.add_timer(5) do
    Prism.redis.lpush_hash "workers:#{instance_id}:worlds:requests:start", world_id:'4e7d843f9fe7af003e000001'
  end
end