#!/usr/bin/env ruby
# encoding: UTF-8

require 'bundler/setup'
Bundler.require :default

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'erb'

abort "Usage: start-local-world id [min_heap] [max_heap]" unless ARGV.length > 0
world_id = ARGV.shift
min_heap_size = ARGV.shift || "1024"
max_heap_size = ARGV.shift || "1024"

exit 0 if LocalWorlds.running.any? {|w| w[:id] == world_id }

def sudo_cmd
  ENV['rvm_version'] ? 'rvmsudo' : 'sudo'
end

def sudo cmd
  `#{sudo_cmd} #{cmd}`
end

def god cmd
  sudo "bundle exec god #{cmd}"
end

def god_running?
  god "status"
  $?.exitstatus == 0
end

def start config_file, world_id
  if god_running?
    god "load #{config_file}"
    god "start #{world_id}"
  else   
    god "-c #{config_file}"
  end
end

def server_properties world_id, port
  col = MinefoldDb.connection['worlds']

  options = col.find_one({'_id' => BSON::ObjectId(world_id)})['options']

  options.merge({
    "allow-flight"     => false,
    "allow-nether"     => true,
    "hellworld"        => false,
    "level-name"       => world_id,
    "level-seed"       => '',
    "max-players"      => 255,
    "motd"             => "\"§aWelcome to Minecraft!@§cHello.§e Build§d something§a fairly§b epic!\"",
    "online-mode"      => true,
    # "pvp"              => true,
    "server-ip"        => "0.0.0.0",
    "server-port"      => port,
    "spawn-animals"    => true,
    # "spawn-monsters"   => false,
    "spawn-protection" => true,
    "view-distance"    => 10,
    "white-list"       => false
  }).map {|values| values.join('=')}.join("\n")
end

puts "Starting world #{world_id}"
`#{BIN}/download-server` unless File.exists? JAR

world_path = "#{WORLDS}/#{world_id}"
properties_path = "#{world_path}/server.properties"
god_path = "#{world_path}/world.god"

# create world path if it aint there
FileUtils.mkdir_p world_path

# check s3 for world
archived_world = Storage.new.worlds.files.get("#{world_id}.tar.gz")
if archived_world
  FileUtils.mkdir_p "#{ROOT}/backups"
  archive = "#{ROOT}/backups/#{world_id}.tar.gz"
  puts "Retrieved world"
  File.open(archive, "w") do |tar|
    tar.write archived_world.body
  end
  Dir.chdir WORLDS do
    TarGz.new.extract archive
  end
else
  puts "New world"
end

# symlink server
FileUtils.ln_s JAR, world_path unless File.exist? "#{world_path}/server.jar"

# get a port number to use
port = LocalWorlds.next_available_port

# create server.properties
File.open(properties_path, 'w') {|file| file.puts server_properties(world_id, port) }

# create world.god
template = ERB.new File.read "#{LIB}/world.god.erb"
File.open(god_path, 'w') {|file| file.puts template.result(binding) }

# clear server log
server_log = File.join(world_path, "server.log")
File.open(server_log, "w") {|file| file.print }

puts "starting server on port #{port}"
start god_path, world_id

puts "Waiting for server init"
Timeout::timeout(5) do
  until LocalWorlds.running.any? {|lw| lw[:id] == world_id }
    sleep 1
  end
end

puts "Waiting for server ready"
begin
  Timeout::timeout(4 * 60) do
    File::Tail::Logfile.open(server_log) do |log|
      log.max_interval = 0.1
      log.interval = 0.1

      log.tail { |line| puts line; raise File::Tail::BreakException if line =~ /Done/ }
    end
  end
rescue File::Tail::BreakException
end