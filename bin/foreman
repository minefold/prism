#!/usr/bin/env ruby
# encoding: UTF-8

require 'bundler/setup'
Bundler.require :foreman

require 'fileutils'

ROOT = File.expand_path File.join(File.dirname(__FILE__), '..')
WORLDS = File.join ROOT, 'worlds'
SERVERS = File.join ROOT, 'foreman/servers'
SERVER_TEMPLATES = File.join ROOT, 'foreman/server_templates'

require 'socket'

def local_ip
  orig, Socket.do_not_reverse_lookup = Socket.do_not_reverse_lookup, true  # turn off reverse DNS resolution temporarily
  UDPSocket.open do |s|
    s.connect '64.233.187.99', 1
    s.addr.last
  end
ensure
  Socket.do_not_reverse_lookup = orig
end

LOCAL_IP = local_ip

module Foreman
  class ServerWatcher < EventMachine::Connection
    attr_accessor :world, :on_exit, :on_started

    def initialize
      @data_recieved = false
    end
    
    def receive_data data
      unless @data_recieved
        @data_recieved = true
        info "Starting"
      end
      started if data =~ /\[INFO\]\sDone/
    end
    
    def started
      info "Ready"
      
      on_started.call
    end
        
    def unbind
      info "Crashed! Restarting"
      on_exit.call
    end
    
    def connection_completed
      info "connection_completed"
    end
    
    
    def info message
      puts "[#{world.name}] #{message}"
    end
  end
  
  class World
    attr_reader :name, :port, :source, :destination
    
    def initialize name, port
      @name = name
      @port = port
      @source = File.join WORLDS, name
      @destination = File.join SERVERS, name
    end
    
    def start_cmd
      %Q{/bin/sh -c "cd '#{destination}' && java -Xmx1024M -Xms512M -jar server.jar nogui 2>&1"}
    end
    
    def create_server
      FileUtils.mkdir_p SERVERS

      return if File.exists? destination

      unless File.exists? source
        FileUtils.mkdir_p source
        FileUtils.cp_r "#{SERVER_TEMPLATES}/default/.", source
      end

      FileUtils.ln_s source, destination
    end
    
    def configure_server
      properties = {
        "level-name" => name,
        "hellworld" =>"false",
        "spawn-monsters"=>"false",
        "online-mode"=>"true",
        "spawn-animals"=>"true",
        "max-players"=>"64",
        "server-ip"=>"0.0.0.0",
        "pvp"=>"true",
        "level-seed"=>"",
        "server-port"=> port,
        "allow-flight"=>"false",
        "white-list"=>"false"
      }

      File.open("#{destination}/server.properties", "w") do |props|
        props.write properties.map {|k,v| "#{k}=#{v}" }.join("\n")
      end
    end
  end
end

DB = Redis.new :host => '0.0.0.0', :port => 6379

# Graceful shutdown
%w(INT TERM).each { |sig| Signal.trap(sig) { EventMachine.stop } }
EM.run do
  
  
  def start_world name, port
    world = Foreman::World.new name, port
    world.create_server
    world.configure_server
    
    EM.popen(world.start_cmd, Foreman::ServerWatcher) do |watcher|
      watcher.world = world
      watcher.on_started = proc do 
        DB.set "servers.#{world.name}", {
          ip:LOCAL_IP,
          port:world.port
        }.to_json
      end
      watcher.on_exit = proc { start_world name, port }
    end
  end
  
  def stop_world name
    
  end
  
  # test server creation
  EM.add_timer(1) { start_world 'superworld', 3000 }
  EM.add_timer(2) { start_world 'worldbot', 3001 }
  EM.add_timer(3) { start_world 'worldinator', 3002 }
  EM.add_timer(4) { start_world 'worldster', 3003 }
  
  # test server shutdown
  
  EM.add_timer(20) { stop_world 'superworld' }
end
