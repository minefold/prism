#!/usr/bin/env ruby

# redis.publish "workers:i-c5031ebe:worlds:503974e29a881b050000001b:stdin", "debug stop"

require 'bundler/setup'
Bundler.require :default, :chatty, :proxy

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'prism/back'
require 'pry'
require 'minecraft/packet'

def redis
  @redis ||= begin
    uri = URI.parse(ENV['REDISTOGO_URL'] || REDISTOGO_URL)
    Redis.new(:host => uri.host, :port => uri.port, :password => uri.password)
  end
end

include Prism::Mongo
def mongo
  @mongo ||= mongo_connect
end

def world world_id
  mongo['worlds'].find_one(_id: BSON::ObjectId(world_id.to_s))
end

def world_backup world_id, new_value = nil
  previous = world(world_id)['world_data_file']
  if new_value
    mongo['worlds'].update({_id: BSON::ObjectId(world_id.to_s)}, {'$set' => {'world_data_file' => new_value}})
    puts "#{previous} => #{new_value}"
  else
    previous
  end
end

def prism_id
  `hostname`.strip
end

def set_players(n, world_id='4f5be9da0ecb2800010000f5')
  n.times do |i|
    redis.hset "players:playing", "player#{i}", world_id
    redis.hset 'usernames', "player#{i}", BSON::ObjectId.new.to_s
  end
end

def clear_players(n)
  n.times {|i| redis.hdel "players:playing", "player#{i}" }
end

def redis_writes
  redis.monitor do |info|
    ts, op, *args = info.split(' ')
    unless args.first =~ /resque/i
      puts "#{op}:#{args.join(' ').ljust(20)}"
    end
  end
end

binding.pry