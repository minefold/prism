#!/usr/bin/env ruby
# encoding: ISO-8859-1

require 'bundler/setup'
Bundler.require :default, :chatty

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'time'
require 'prism/prism_redis'

STDOUT.sync = true

abort "Usage: chatty world_id" unless ARGV.length == 1
world_id = ARGV.shift

Pusher.url = PUSHER_URL

class LogReader < EventMachine::FileTail
  attr_accessor :world_id
  
  def initialize(path, startpos=-1)
    super(path, startpos)
    puts "Tailing #{path}"
    @buffer = BufferedTokenizer.new
    
    yield self
  end
  
  def world_objectid
    BSON::ObjectId(world_id)
  end
  
  def receive_data(data)
    @buffer.extract(data.force_encoding('ISO-8859-1')).each do |l|
      line = LogLine.new l
      if line.chat_user
        # push onto redis queue, don't use mongo
        Resque.push('high', :class => 'SaveChatMessage', :args => [ "#{world_objectid}", line.chat_user, line.chat_message ])
        
        puts "[#{line.chat_user}] #{line.chat_message}"
      end
    end
  end
end

EM.epoll
EM.run do
  @local_world = LocalWorld.new world_id
  
  input_channel = "worlds:#{world_id}:stdin"
  puts "[#{Fold.env}] online subscribed:#{input_channel} tailing:#{@local_world.server_log}"
  
  subscription = Prism::PrismRedis.connect
  subscription.subscribe input_channel
  subscription.on(:message) {|channel, message| @local_world.console_message message }
  
  EventMachine::file_tail(@local_world.server_log, LogReader) {|r| r.world_id = world_id }
  
  EM::PeriodicTimer.new(1 * 60) do
    puts "starting backup:#{world_id}"
    @local_world.disable_world_saving
    # wait 3 secs so the world has stopped saving
    EM.add_timer(3) do
      EM.defer(proc { @local_world.backup! }, proc { 
          @local_world.enable_world_saving
          puts "backup completed:#{world_id}"
        })
    end
  end  
  
  EM::PeriodicTimer.new(5 * 60) do
    Resque.enqueue(Job::MapWorld, world_id)
  end
end