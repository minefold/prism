#!/usr/bin/env ruby

require 'bundler/setup'
Bundler.require :default, :chatty

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'time'
require 'em_pub_sub'

STDOUT.sync = true

abort "Usage: chatty world_id" unless ARGV.length == 1
world_id = ARGV.shift

class LogLine
  attr_reader :line, :timestamp, :level, :message, :chat_user, :chat_message

  def initialize line
    @line = line
    line =~ /(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\s\[(\w+)\]\s(.*)/
    @timestamp = Time.parse $1
    @level = $2
    @message = $3

    message =~ /^\<(\w+)\> (.*)/
    @chat_user = $1
    @chat_message = $2
  end
end

Pusher.url = PUSHER_URL

EM.epoll
EM.run do
  @local_world = LocalWorld.new world_id
  
  connection = MinefoldDb.connection

  users_collection = connection['users']
  worlds_collection = connection['worlds']
  wall_items_collection = connection['wall_items']

  world_objectid = BSON::ObjectId(world_id)
  
  input_channel = "world.#{world_id}.input"
  
  @sub = EMPubSub.connect
  @sub.subscribe(input_channel) do |type, channel, message|
    @local_world.console_message "#{message}" if type == "message"
  end
  
  puts "[#{Fold.env}] online subscribed:#{input_channel} tailing:#{@local_world.server_log}"
  EventMachine::file_tail @local_world.server_log do |filetail, l|
    line = LogLine.new l
    if line.chat_user
      # TODO: WHAT IF THE USER DOESN'T EXIST?
      user = users_collection.find({'username' => line.chat_user}).first

      result = wall_items_collection.insert(
        '_type' => 'Chat',

        'wall_type' => 'World',
        'wall_id' => world_objectid,

        'user_id' => user['_id'],

        'body' => line.chat_message,
        'username' => line.chat_user,
        'created_at' => line.timestamp,
        'updated_at' => line.timestamp
      )
      puts "[#{result}] #{line.timestamp} [#{line.chat_user}] #{line.chat_message}"
      
      Pusher["world:#{world_id}"].trigger_async "chat:create", {
        user: {
          username: line.chat_user
        },
        body: line.chat_message
      }.to_json
      
    end
  end
  
  EM::PeriodicTimer.new(1 * 60) do
    puts "starting backup:#{world_id}"
    @local_world.disable_world_saving
    EM.defer(proc { @local_world.backup! }, proc { 
        @local_world.enable_world_saving
        puts "backup completed:#{world_id}"
      })
  end  
  
  EM::PeriodicTimer.new(5 * 60) do
    Resque.enqueue(Job::MapWorld, world_id)
  end
end