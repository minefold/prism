#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'logger'
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'

Thread.abort_on_exception = true

CONNECTED_PLAYERS = {}

module Client
  attr_accessor :log

  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
  end

  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')
      
      @world_name = "bigbird"

      log.info(:proxy) { "#{@username} connected, sending to #{@world_name}"}
      
      keepalive = EventMachine::PeriodicTimer.new(1) do
        send_data [0].pack('C')
      end
      
      ensure_world_started = proc do
        @worker = Workers.running.find {|worker| worker.worlds.any? {|world| world.name == @world_name } }
        @worker = Workers.start unless @worker
        
        @world = @worker.worlds.find {|world| world.name == @world_name }
        @world = @worker.worlds.start @world_name unless @world
        @world
      end
      
      EventMachine.defer( ensure_world_started, proc { |world| 
          host = world.worker.public_ip_address
          @server = EventMachine.connect(host, world.port, Server) do |server|
            server.plexer = self
            log.info(:proxy) { "#{@username} proxied to #{host}:#{world.port}"}
          end
          keepalive.cancel
          @f_connection_established.succeed
          CONNECTED_PLAYERS[@world_name] ||= []
          CONNECTED_PLAYERS[@world_name] << @username
          log.info(:proxy) { "#{@world_name}: #{CONNECTED_PLAYERS[@world_name].length} player(s)"}
        
        })
      
    end

    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access
    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        log.warn(:proxy) { 'unable to connect'}
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end

  # It seems like eventmachine is quite slow unbinding the connection. I tried
  # closing it earlier by parsing the 0x255 message but it still exhibited the
  # same behaviour. Strangely, if you cancel loading the world the connection
  # unbinds quicker...
  def unbind
    log.info(:proxy) { "#{@username} unbound"}
    CONNECTED_PLAYERS[@world_name] ||= []
    CONNECTED_PLAYERS[@world_name].delete @username
    log.info(:proxy) { "#{@world_name}: #{CONNECTED_PLAYERS[@world_name].length} player(s)"}
    if CONNECTED_PLAYERS[@world_name].length == 0
      EventMachine.defer( proc { @worker.stop_world @world_name  }, proc { 
        # EventMachine::DeferrableChildProcess.open "#{ROOT}/bin/stop-worker #{@worker.instance_id}" 
      })
    end
  end

end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end
end

EventMachine.run do
  logger = Logger.new(STDOUT)

  EventMachine.start_server('0.0.0.0', 25565, Client) do |connection|
    connection.log = logger
  end

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      EventMachine.stop
      logger.info(:proxy) { 'terminated'}
    end
  end

  logger.info(:proxy) { 'started on 0.0.0.0:25565'}
end
