#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'environment'
require 'minefold'
require 'proxy_info_handler'
require 'sauron'
require 'logger'

Thread.abort_on_exception = true
STDOUT.sync = true

puts "Connecting to Mongo"
DB = MinefoldDb.connection

CONNECTED_PLAYERS = {}
BUSY_WORKERS = {}  # worker is either starting, stopping or starting a new world (ie. busy, don't use it)
SUPERVISED_WORLDS = {} # world is running, starting or stopping (ie. connect for it or wait)

WORKER_INSTANCE_TYPE = ENV['WORKER_INSTANCE_TYPE'] || "t1.large"

module Client
  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
    @client_connected = true
    @min_heap_size, @max_heap_size = 512, 512
    @instance_type = WORKER_INSTANCE_TYPE
  end
  
  def info message
    puts "[#{@username||''}@#{@world_id||''}] #{message}"
  end

  def warn message
    puts "WARNING: #{message}"
  end
  
  def error message, e = nil
    error_message = ""
    error_message = [e.inspect, e.backtrace].join("\n") if e
    puts "ERROR: #{message}" + error_message
    nil
  end
  
  
  def get_world_running
    return unless @client_connected
    
    # scenarios:
    #  World is running > connect
    #  World is starting > retry later
    #  World is stopping (backing up) > retry later
    #  World is stopped, worker is starting > retry later
    #  World is stopped, worker is running > start world then connect
    
    #  World not claimed, running worker with no world available > start world then connect
    #  World not claimed, stopped worker available > start worker then retry
    #  World not claimed, no worker available > create new worker then connect
    
    #  Start world on instance failed > stop instance then retry
    supervised_world = SUPERVISED_WORLDS[@world_id]
    
    if supervised_world
      if supervised_world.running?
        proxy_client supervised_world.worker, supervised_world.world
      else
        # world is stopping or starting, so we'll wait
        EM.add_timer(5) { 
          info "waiting for world:#{supervised_world}"
          get_world_running
        }
      end
    else
      # no world starting, running, or stopping. We should start one
      supervised_world = SUPERVISED_WORLDS[@world_id] = SupervisedWorld.new(:starting)
      
      # query ec2 for workers
      EM.defer(proc { 
        begin
          # find workers that we haven't marked as busy and sort by who has the most available time
          Workers.existing.reject{|w| BUSY_WORKERS.has_key? w.instance_id }.sort_by {|w| (w.uptime_minutes % 60) }
        rescue => e
          error "Workers.existing", e
        end
      }, proc {|workers| 
        if @client_connected
          if workers
            idle_worker = workers.find {|w| w.server.state == 'running' && w.responding? && w.worlds.count == 0 } 
            if idle_worker
              # there is an idle worker available to us
              info "using idle worker #{idle_worker.instance_id} to start world"
              start_world idle_worker
            else
              # stopped_worker = workers.find{|w| w.server.state == 'stopped' }
              # if stopped_worker
              #   # theres a stopped worker we can start and use
              #   info "starting stopped worker #{stopped_worker.instance_id}"
              #   start_worker_and_world stopped_worker
              # else
                # no workers, lets create one
                info "creating new worker"
                create_worker_and_start_world
              # end
            end
          else
            # error getting workers, give up?
            SUPERVISED_WORLDS.delete @world_id
            warn "Fatal. can't contact workers"
            close_connection
          end
        else
          SUPERVISED_WORLDS.delete @world_id
          info "Player disconnected. Won't start world"
        end
      })
    end
  end
  
  def proxy_client worker, world
    return unless @client_connected
    
    host, port = worker.public_ip_address, world.port

    @server = EventMachine.connect(host, port, Server) do |server|
      server.plexer = self
      info "proxied to #{host}:#{port}"
    end
    @keepalive.cancel if @keepalive
    
    @credit_muncher = EventMachine::PeriodicTimer.new(60) do
      deduct_minutes 1
    end
    info "starting credit muncher:#{@credit_muncher}"
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id] << @username unless CONNECTED_PLAYERS[@world_id].include? @username
    info "#{CONNECTED_PLAYERS[@world_id].length} player(s)"
    
    @f_connection_established.succeed
  end
  
  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      # Lookup username from Mongo
      @user = DB['users'].find_one(:username => @username)

      # TODO: Untested, mongo may raise an error. Hopefully, instead it
      #       returns nil and the client connected is dropped.
      # TODO: Separate method for dropping a connection rather than unbinding
      #       as logging/stats need to be different.
      unless @user && @user['world_id']
        info "unauthorised player"
        return close_connection
      end
      
      unless @user['credits'] > 0
        info "no credit remaining"
        return close_connection
      end
      
      @user_objectid, @world_id = @user['_id'], @user['world_id'].to_s
      
      info "connected. #{@user['credits']} credits remaining"

      @keepalive = EventMachine::PeriodicTimer.new(5) do
        send_data [0].pack('C')
      end
      EM.next_tick { get_world_running }
    end
    
    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access
    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        warn 'unable to connect'
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end

  def deduct_minutes amount
    return unless @client_connected
    
    EM.defer do
      user = DB['users'].find_and_modify({ 
                    query: {"_id"  => @user_objectid},
                    update:{"$inc" => {"credits"=>-amount }}
                  })
      info "deducting 1 credit. #{user['credits']} remaining."

      if user['credits'] <= amount
        EM.next_tick do
          info "disconnecting. 0 minutes remaining"
          close_connection
        end
      end
    end
  end
  
  # sometimes crashes the client...
  # def send_chat_message message
  #   
  #   data = [0x03].pack('C')
  #   data << [message.size, message.encode('UTF-16BE')].pack("na*")
  #   send_data data
  # end
  
  def unbind
    @client_connected = false
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id].delete @username
    info "client disconnected. #{CONNECTED_PLAYERS[@world_id].length} player(s) in world"
    
    @keepalive.cancel if @keepalive
    info "stopping credit muncher:#{@credit_muncher}"
    @credit_muncher.cancel if @credit_muncher
    
    if @world_id && SUPERVISED_WORLDS[@world_id] && CONNECTED_PLAYERS[@world_id].length == 0
      if SUPERVISED_WORLDS[@world_id].running?
        info "Stopping world:#{@world_id}"
        stop_world SUPERVISED_WORLDS[@world_id], @world_id
      end
    end
    
  end
  
  # async methods
  def create_worker_and_start_world
    EM.defer(proc { 
        begin
          Workers.create flavor_id:@instance_type
        rescue => e
          error "create worker", e
        end
      }, proc { |worker| 
        if worker
          EM.next_tick { start_world worker }
        else
          # create worker failed, mark as bad, we'll try again
          SUPERVISED_WORLDS.delete @world_id
          BUSY_WORKERS[worker.instance_id] = :not_responding
          EM.next_tick { get_world_running }
        end
    })
  end
  
  def start_worker_and_world worker
    BUSY_WORKERS[worker.instance_id] = :starting
    
    EM.defer(proc { 
        begin
          worker.start!
        rescue => e
          error "worker start", e
        end 
      }, proc { |worker|
        if worker
          BUSY_WORKERS.delete worker.instance_id
          info "started stopped worker #{worker.instance_id}"
          EM.next_tick { start_world worker }
        else
          # worker start failed, never started the world so forget about it
          SUPERVISED_WORLDS.delete @world_id
          BUSY_WORKERS[worker.instance_id] = :not_responding
          EM.next_tick { get_world_running }
        end
    })
  end
  
  def start_world worker
    unless @client_connected
      # don't start world, client is gone
      SUPERVISED_WORLDS.delete @world_id
      return
    end
    
    SUPERVISED_WORLDS[@world_id].worker = worker
    BUSY_WORKERS[worker.instance_id] = :starting_world
    
    info "starting world:#{@world_id} on #{worker.instance_id}"
    EM.defer(proc { 
        begin
          worker.start_world @world_id, @min_heap_size, @max_heap_size
        rescue => e
          error "start world", e
        end
      }, proc {|world|
        if world
          BUSY_WORKERS.delete worker.instance_id
          SUPERVISED_WORLDS[@world_id].world = world
          SUPERVISED_WORLDS[@world_id].running!
        else
          # couldn't start world, mark worker as bad
          SUPERVISED_WORLDS.delete @world_id
          BUSY_WORKERS[worker.instance_id] = :not_responding
        end
        EM.next_tick { get_world_running }
    })
  end
  
  # def terminate_bad_worker_and_retry worker
  #   EM.defer(proc { 
  #       begin
  #         info "terminating bad worker"
  #         worker.terminate! if worker
  #       rescue => e
  #         error "worker terminate", e
  #       end
  #     }, proc { BUSY_WORKERS.delete worker.instance_id if worker })
  #   
  #   # clean up and try again
  #   
  #   EM.next_tick { get_world_running }
  # end
  
  def stop_world supervised_world, world_id
    SUPERVISED_WORLDS[world_id].stopping!
    EM.defer(proc { 
        begin
          world = supervised_world.worker.stop_world world_id
          info "world stopped"
          world
        rescue => e
          error "stop world", e
        end
      }, proc {
        SUPERVISED_WORLDS.delete world_id
    })
  end
  
  # synchronous methods
  def find_idle_workers
    running_workers = Workers.running
    running_workers.each do |w|
      debug "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes} worlds:#{w.worlds.count}"
    end
    # only return workers that are unsupervised and have no worlds (ie. not starting or stopping)
    idle_workers = running_workers.select{|w| w.worlds.count == 0 }.reject{|w| BUSY_WORKERS.has_key? w.instance_id } 
    idle_workers.sort_by { |w| (w.uptime_minutes % 60) }
  end
  
end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end

  # TODO: Unbind method. If the server on our end goes down, create a shit
  #       storm.

end

EventMachine.epoll
EventMachine.run do
  puts 'collecting initial state'
  
  Workers.running.each do |worker|
    if worker.responding?
      worlds = worker.worlds
      worlds.each do |world| 
        SUPERVISED_WORLDS[world.id] = SupervisedWorld.new :running, worker, world
      end
      puts "worker:#{worker.instance_id} uptime_minutes:#{worker.uptime_minutes} worlds:#{worlds.count}"
    else
      puts "worker:#{worker.instance_id} not responding"
      BUSY_WORKERS[worker.instance_id] = :not_responding
    end
  end
  
  # listen for minecraft connections
  EventMachine.start_server('0.0.0.0', 25565, Client)
  
  # listen for http connections
  EventMachine::start_server("0.0.0.0", 8081, ProxyInfoHandler)

  find_idle_workers = proc { 
    running_workers = Workers.running
    running_workers.reject {|w| BUSY_WORKERS[w.instance_id] }.each do |w|
      if w.responding?
        world_ids = w.worlds.map(&:id)
        player_count = world_ids.inject(0) {|count, world_id| count + CONNECTED_PLAYERS[world_id].count }
        puts "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes} worlds:#{w.worlds.count} players:#{player_count}"
      else
        puts "worker:#{w.instance_id} not responding"
        BUSY_WORKERS[w.instance_id] = :not_responding
      end
    end
    idle_workers = running_workers.select{|w| w.worlds.count == 0 && (w.uptime_minutes % 60) > 55 } 
    puts "Found #{idle_workers.count} idle workers"
    idle_workers
  }
  
  idle_killer = EventMachine::PeriodicTimer.new(4 * 60) do 
    # shutdown idle workers
    
    EM.defer(find_idle_workers, proc { |workers|
        workers.each do |w|
          BUSY_WORKERS[w.instance_id] = :stopping
          EM.defer(proc{
              begin
                puts "Terminating idle worker:#{w.instance_id} uptime:#{w.uptime_minutes}"
                w.terminate!
              rescue => e
                puts "Error stopping idle worker\n#{e.message}\n#{e.backtrace}"
              end
            }, proc {
              BUSY_WORKERS.delete w.instance_id
          })
        end
    })
  end
  
  bad_worker_detective = EventMachine::PeriodicTimer.new(20) do 
    recover_bad_workers = proc {
      recovered_workers = []
      BUSY_WORKERS.select {|instance_id, state| state == :not_responding }.each do |instance_id, state|
        begin
          BUSY_WORKERS[instance_id] = :diagnosing
          puts "Diagnosing worker:#{instance_id}"
          worker = Workers.get instance_id
          worker.wait_for_ssh timeout:20
          worker.prepare_for_minefold
          # if all that worked, we're up and running!
          recovered_workers << instance_id
        rescue => e
          # no dice!
          puts "ERROR: #{[e.inspect, e.backtrace].join("\n")}"
          BUSY_WORKERS[instance_id] = :not_responding
        end
      end
      recovered_workers
    }
    make_workers_available = proc {|worker_ids|
        worker_ids.each{|id| 
          puts "worker:#{id} back on duty"
          BUSY_WORKERS.delete id 
        }
      }
    
    EM.defer(recover_bad_workers, make_workers_available)
  end
  

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      idle_killer.cancel
      EventMachine.stop
      puts 'terminated'
    end
  end

  puts "listening on 0.0.0.0:25565. Creating #{WORKER_INSTANCE_TYPE} workers"
end
