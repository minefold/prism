#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'environment'
require 'minefold'
require 'proxy_info_handler'
require 'sauron'
require 'logger'

Thread.abort_on_exception = true
STDOUT.sync = true

DB = MinefoldDb.connection

CONNECTED_PLAYERS = {}
BUSY_WORKERS = {}  # worker is either starting, stopping or starting a new world (ie. busy, don't use it)
SUPERVISED_WORLDS = {} # world is running, starting or stopping (ie. connect for it or wait)

module Client
  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
  end
  
  def info message
    puts "[#{@username||''}@#{@world_id||''}] #{message}"
  end

  def warn message
    puts "WARNING: #{message}"
  end
  
  def error message, e
    puts "ERROR: " + [message, e.message, e.backtrace].join("\n")
    nil
  end
  
  
  def get_world_running
    # scenarios:
    #  World is running > connect
    #  World is starting > retry later
    #  World is stopping (backing up) > retry later
    #  World is stopped, worker is starting > retry later
    #  World is stopped, worker is running > start world then connect
    
    #  World not claimed, running worker with no world available > start world then connect
    #  World not claimed, stopped worker available > start worker then retry
    #  World not claimed, no worker available > create new worker then connect
    
    #  Start world on instance failed > stop instance then retry
    
    @supervised_world = SUPERVISED_WORLDS[@world_id]
    
    if @supervised_world
      if @supervised_world.running?
        proxy_client
      else
        # world is stopping or starting, so we'll wait
        EM.add_timer(5) { 
          info "waiting for world:#{@supervised_world}"
          get_world_running
        }
      end
    else
      # no world starting, running, or stopping. We should start one
      @supervised_world = SUPERVISED_WORLDS[@world_id] = SupervisedWorld.new(:starting)
      
      # query ec2 for workers
      EM.defer(proc { 
        begin
          # find workers that we haven't marked as busy and sort by who has the most available time
          Workers.existing.reject{|w| BUSY_WORKERS.has_key? w.instance_id }.sort_by {|w| (w.uptime_minutes % 60) }
        rescue => e
          error "Workers.existing", e
        end
      }, proc {|workers| 
        if workers
          idle_worker = workers.find {|w| w.server.state == 'running' && w.worlds.count == 0 } 
          if idle_worker
            # there is an idle worker available to us
            info "using idle worker #{idle_worker.instance_id} to start world"
            start_world idle_worker
          else
            stopped_worker = workers.find{|w| w.server.state == 'stopped' }
            if stopped_worker
              # theres a stopped worker we can start and use
              info "starting stopped worker #{stopped_worker.instance_id}"
              start_worker_and_world stopped_worker
            end
          end
        else
          info "creating new worker"
          create_worker_and_start_world
        end
      })
    end
  end
  
  def proxy_client
    host = @supervised_world.worker.public_ip_address
    port = @supervised_world.world.port
    @server = EventMachine.connect(host, port, Server) do |server|
      server.plexer = self
      info "proxied to #{host}:#{port}"
    end
    @keepalive.cancel if @keepalive
    @wait_for_world.cancel if @wait_for_world
    
    @credit_muncher = EventMachine::PeriodicTimer.new(60) do
      deduct_minutes 1
    end
    puts "starting credit muncher:#{@credit_muncher}"
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id] << @username unless CONNECTED_PLAYERS[@world_id].include? @username
    info "#{CONNECTED_PLAYERS[@world_id].length} player(s)"
    
    @f_connection_established.succeed
  end

  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      # Lookup username from Mongo
      @user = DB['users'].find_one(:username => @username)

      # TODO: Untested, mongo may raise an error. Hopefully, instead it
      #       returns nil and the client connected is dropped.
      # TODO: Separate method for dropping a connection rather than unbinding
      #       as logging/stats need to be different.
      unless @user && @user['world_id']
        info "unauthorised player"
        return close_connection
      end
      
      unless @user['credits'] > 0
        info "no credit remaining"
        return close_connection
      end
      
      @user_objectid, @world_id = @user['_id'], @user['world_id'].to_s
      
      info "connected. #{@user['credits']} credits remaining"
      
      @supervised_world ||= SUPERVISED_WORLDS[@world_id]
      
      if @supervised_world && @supervised_world.running?
        proxy_client
      else
        @keepalive = EventMachine::PeriodicTimer.new(5) do
          send_data [0].pack('C')
        end
        get_world_running
      end
    end
    
    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access
    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        warn 'unable to connect'
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end

  def deduct_minutes amount
    EM.defer do
      info "deducting 1 credit"
      user = DB['users'].find_and_modify({ 
                    query: {"_id"  => @user_objectid},
                    update:{"$inc" => {"credits"=>-amount }}
                  })

      if user['credits'] <= amount
        EM.next_tick do
          info "disconnecting. 0 minutes remaining"
          close_connection
        end
      end
    end
  end
  
  # sometimes crashes the client...
  # def send_chat_message message
  #   
  #   data = [0x03].pack('C')
  #   data << [message.size, message.encode('UTF-16BE')].pack("na*")
  #   send_data data
  # end
  
  def unbind
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id].delete @username
    info "client disconnected. #{CONNECTED_PLAYERS[@world_id].length} player(s) in world"
    
    @keepalive.cancel if @keepalive
    @wait_for_world.cancel if @wait_for_world
    puts "stopping credit muncher:#{@credit_muncher}"
    @credit_muncher.cancel if @credit_muncher
    
    if @world_id && @supervised_world && CONNECTED_PLAYERS[@world_id].length == 0
      info "Stopping world:#{@world_id}"
      stop_world @supervised_world, @world_id
    end
  end
  
  # async methods
  def create_worker_and_start_world
    EM.defer(proc { 
        begin
          Workers.create 
        rescue => e
          error "create worker", e
        end
      }, proc { |worker| 
        if worker
          EM.next_tick { start_world worker }
        else
          error "Fatal. Closing connection"
          close_connection
        end
    })
  end
  
  def start_worker_and_world worker
    BUSY_WORKERS[worker.instance_id] = worker
    
    EM.defer(proc { 
        begin
          worker.start!
        rescue => e
          error "worker start", e
        end 
      }, proc { |worker|
        if worker
          info "started stopped worker #{worker.instance_id}"
          EM.next_tick { start_world worker }
        else
          terminate_bad_worker_and_retry worker
        end
    })
  end
  
  def start_world worker
    @supervised_world.worker = worker
    BUSY_WORKERS[worker.instance_id] = worker
    
    info "starting world:#{@world_id} on #{worker.instance_id}"
    EM.defer(proc { 
        begin
          worker.start_world @world_id 
        rescue => e
          error "start world", e
        end
      }, proc {|world|
        if world
          @supervised_world.world = world
          BUSY_WORKERS.delete worker.instance_id
        
          proxy_client
        else
          # couldn't start world
          # assume worker is bad then terminate
          terminate_bad_worker_and_retry worker
        end
    })
  end
  
  def terminate_bad_worker_and_retry worker
    EM.defer(proc { 
        begin
          worker.terminate!
        rescue => e
          error "worker terminate", e
        end
      }, proc { BUSY_WORKERS.delete worker.instance_id })
    
    # clean up and try again
    @supervised_world.worker = nil
    EM.next_tick { get_world_running }
  end
  
  def stop_world supervised_world, world_id
    EM.defer(proc { 
        begin
          supervised_world.worker.stop_world world_id
        rescue => e
          error "stop world", e
        end
      }, proc {
        info "world stopped"
        SUPERVISED_WORLDS.delete world_id
    })
  end
  
  # synchronous methods
  def find_idle_workers
    running_workers = Workers.running
    running_workers.each do |w|
      debug "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes} worlds:#{w.worlds.count}"
    end
    # only return workers that are unsupervised and have no worlds (ie. not starting or stopping)
    idle_workers = running_workers.select{|w| w.worlds.count == 0 }.reject{|w| BUSY_WORKERS.has_key? w.instance_id } 
    idle_workers.sort_by { |w| (w.uptime_minutes % 60) }
  end
  
end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end

  # TODO: Unbind method. If the server on our end goes down, create a shit
  #       storm.

end

EventMachine.epoll
EventMachine.run do
  puts 'collecting initial state'
  
  Workers.existing.each do |worker|
    worker.worlds.each do |world| 
      SUPERVISED_WORLDS[world.id] = SupervisedWorld.new :running, worker, world
    end
  end
  
  # listen for minecraft connections
  EventMachine.start_server('0.0.0.0', 25565, Client)
  
  # listen for http connections
  EventMachine::start_server("0.0.0.0", 8081, ProxyInfoHandler)

  find_idle_workers = proc { 
    running_workers = Workers.running
    running_workers.each do |w|
      puts "worker:#{w.instance_id} uptime_minutes:#{w.uptime_minutes!} worlds:#{w.worlds.count}"
    end
    idle_workers = running_workers.select{|w| w.worlds.count == 0 && (w.uptime_minutes! % 60) > 55 } 
    puts "Found #{idle_workers.count} idle workers"
    idle_workers
  }
  
  idle_killer = EventMachine::PeriodicTimer.new(4 * 60) do 
    # shutdown idle workers
    
    EM.defer(find_idle_workers, proc { |workers|
        workers.each do |w|
          BUSY_WORKERS[w.instance_id] = w
          EM.defer(proc{
              puts "Stopping idle worker:#{w.instance_id} uptime:#{w.uptime_minutes}"
              w.stop!
            }, proc {
              BUSY_WORKERS.delete w.instance_id
          })
        end
    })
  end

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      idle_killer.cancel
      EventMachine.stop
      puts 'terminated'
    end
  end

  puts 'started on 0.0.0.0:25565'
end
