#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'
require 'prism'
require 'sauron'
require 'logger'

Thread.abort_on_exception = true
STDOUT.sync = true

puts "Connecting to Mongo"
DB = MinefoldDb.connection

CONNECTED_PLAYERS = {}
BUSY_WORKERS = {}  # worker is either starting, stopping or starting a new world (ie. busy, don't use it)
SUPERVISED_WORLDS = {} # world is running, starting or stopping (ie. connect for it or wait)

MAX_WORLDS_PER_WORKER = 2

WORKER_INSTANCE_TYPE = ENV['WORKER_INSTANCE_TYPE'] || "m1.large"

module ProxyLogging
  def info message
    puts message
  end
  
  def warn message
    puts "WARNING: #{message}"
  end
  
  def error message, e = nil
    error_message = ""
    error_message = [e.inspect, e.backtrace].join("\n") if e
    puts "ERROR: #{message}" + error_message
    nil
  end
end

module ProxyAsyncMethods
  def stop_world world_id
    return unless SUPERVISED_WORLDS[world_id] && SUPERVISED_WORLDS[world_id].running?
    
    SUPERVISED_WORLDS[world_id].stopping!
    worker = SUPERVISED_WORLDS[world_id].worker
    
    EM.defer(proc { 
        begin
          world = worker.stop_world world_id
          info "world stopped"
          world
        rescue => e
          error "stop world", e
        end
      }, proc {
        SUPERVISED_WORLDS.delete world_id
    })
  end
end

module Client
  include ProxyLogging
  include ProxyAsyncMethods
  include Minefold::Redis
  include Prism::ChatMessaging
  include Prism::CreditMuncher
  
  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
    @client_connected = true
    @min_heap_size, @max_heap_size = 512, 4096
    @instance_type = WORKER_INSTANCE_TYPE
  end
  
  def info message
    puts "[#{@username||''}@#{@world_id||''}] #{message}"
  end
    
  def get_world_running
    return unless @client_connected
    
    # scenarios:
    #  World is running > connect
    #  World is starting > retry later
    #  World is stopping (backing up) > retry later
    #  World is stopped, worker is starting > retry later
    #  World is stopped, worker is running > start world then connect
    
    #  World not claimed, running worker with no world available > start world then connect
    #  World not claimed, stopped worker available > start worker then retry
    #  World not claimed, no worker available > create new worker then connect
    
    #  Start world on instance failed > stop instance then retry
    supervised_world = SUPERVISED_WORLDS[@world_id]
    
    if supervised_world
      if supervised_world.running?
        if supervised_world.worker.responding? && supervised_world.worker.world(@world_id)
          proxy_client supervised_world.worker, supervised_world.world
        else
          # we thought world was running but bzzzzzzt! it's gone.
          puts "world is not running"
          SUPERVISED_WORLDS.delete @world_id
          EM.next_tick { get_world_running }
        end
      else
        # world is stopping or starting, so we'll wait
        EM.add_timer(5) { 
          info "waiting for world:#{supervised_world}"
          get_world_running
        }
      end
    else
      # no world starting, running, or stopping. We should start one
      supervised_world = SUPERVISED_WORLDS[@world_id] = SupervisedWorld.new(:starting)
      
      # query ec2 for workers
      EM.defer(proc { 
        begin
          # find workers that we haven't marked as busy and sort by who has the most available time
          Worker.all.reject{|w| BUSY_WORKERS.has_key? w.instance_id }.sort_by {|w| (w.uptime_minutes % 60) }
        rescue => e
          error "Worker.all", e
        end
      }, proc {|workers| 
        if @client_connected
          if workers
            available_worker = workers.find {|w| w.server.state == 'running' && w.responding? && w.worlds.count < MAX_WORLDS_PER_WORKER } 
            if available_worker
              # there is an idle worker available to us
              info "using running worker #{available_worker.instance_id} to start world"
              start_world available_worker
            else
              stopped_worker = workers.find{|w| w.server.state == 'stopped' }
              if stopped_worker
                # theres a stopped worker we can start and use
                info "starting stopped worker #{stopped_worker.instance_id}"
                start_worker_and_world stopped_worker
              else
                # no workers, lets create one
                info "creating new worker"
                create_worker_and_start_world
              end
            end
          else
            # error getting workers, give up?
            SUPERVISED_WORLDS.delete @world_id
            warn "Fatal. can't contact workers"
            close_connection
          end
        else
          SUPERVISED_WORLDS.delete @world_id
          info "Player disconnected. Won't start world"
        end
      })
    end
  end
  
  def proxy_client worker, world
    return unless @client_connected
    
    host, port = worker.public_ip_address, world.port

    @server = EventMachine.connect(host, port, Server) do |server|
      server.plexer = self
      info "proxied to #{host}:#{port}"
    end
    @keepalive.cancel if @keepalive
    
    @credit_muncher = EventMachine::PeriodicTimer.new(60) do
      deduct_minutes 1
    end
    info "starting credit muncher:#{@credit_muncher}"
    
    EM.defer {
      Resque.push('low', :class => 'Verify', :args => [ @username, Time.now.utc ])
      # Resque.push('player_connections', :class => 'PlayerConnected', :args => [ "#{@user_objectid}" ])
      
      redis.sadd "world:#{@world_id}:connected_players", "#{@user_objectid}" 
      redis.sadd "world:running", "#{@world_id}"
    }
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id] << @username unless CONNECTED_PLAYERS[@world_id].include? @username

    player_count = CONNECTED_PLAYERS[@world_id].length
    info "#{player_count} player(s)"
    
    send_delayed_message 7,  "Hi #{@username} welcome to minefold!"
    send_delayed_message 13, "You have #{time_in_words @user['credits']} of play remaining"
    send_delayed_message 17, "There #{player_count == 1 ? 'is' : 'are'} #{pluralize player_count, "player"} in this world"
    
    @f_connection_established.succeed
  end
  
  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      # Lookup username from Mongo
      @user = DB['users'].find_one(:username => /#{@username}/i)

      # TODO: Untested, mongo may raise an error. Hopefully, instead it
      #       returns nil and the client connected is dropped.
      unless @user && @user['world_id']
        info "unauthorised player"
        return close_connection
      end
      
      unless @user['credits'] > 0
        info "no credit remaining"
        return close_connection
      end
      
      @user_objectid, @world_id = @user['_id'], @user['world_id'].to_s
      
      info "connected. #{@user['credits']} credits remaining"

      @keepalive = EventMachine::PeriodicTimer.new(5) do
        send_data [0].pack('C')
      end
      EM.next_tick { get_world_running }
    end
    
    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access
    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        warn 'unable to connect'
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end
  
  def minutes_updated amount
    messages = {
      30 => "You have 30 minutes remaining",
      10 => "You have 10 minutes remaining",
      5  => "You have 5 minutes remaining!",
      1  => "You have 1 minute remaining!"
    }.freeze
    
    if message = messages[amount]
      send_delayed_message 0.1, message
      if amount == 1
        send_delayed_message 30, "To continue playing, top up your account at minefold.com!"
      end
    end
    
    EM.defer { CreditMailer.send_low_credit "#{@user_objectid}" } if amount == 30
  end

  # sometimes crashes the client...
  # def send_chat_message message
  #   
  #   data = [0x03].pack('C')
  #   data << [message.size, message.encode('UTF-16BE')].pack("na*")
  #   send_data data
  # end
  
  def unbind
    @client_connected = false
    
    EM.defer { 
      redis.srem "world:#{@world_id}:connected_players", "#{@user_objectid}"
    }
    
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id].delete @username
    info "client disconnected. #{CONNECTED_PLAYERS[@world_id].length} player(s) in world"
    
    @keepalive.cancel if @keepalive
    info "stopping credit muncher:#{@credit_muncher}"
    @credit_muncher.cancel if @credit_muncher
    
    if @world_id && SUPERVISED_WORLDS[@world_id] && CONNECTED_PLAYERS[@world_id].length == 0
      if SUPERVISED_WORLDS[@world_id].running?
        info "Stopping world:#{@world_id}"
        stop_world @world_id
      else
        puts "World not started, nothing to stop"
      end
    end
    
  end
  
  # async methods
  def create_worker_and_start_world
    EM.defer(proc { 
        begin
          Worker.create flavor_id:@instance_type
        rescue => e
          error "create worker", e
        end
      }, proc { |worker| 
        if worker
          EM.next_tick { start_world worker }
        else
          error "no worker"
          # create worker failed, we don't have its instance id, we'll try again
          SUPERVISED_WORLDS.delete @world_id
          EM.next_tick { get_world_running }
        end
    })
  end
  
  def start_worker_and_world worker
    BUSY_WORKERS[worker.instance_id] = :starting
    
    instance_id = worker.instance_id
    
    EM.defer(proc { 
        begin
          worker.start!
        rescue => e
          error "worker start", e
        end 
      }, proc { |worker|
        if worker
          BUSY_WORKERS.delete instance_id
          info "started stopped worker #{instance_id}"
          EM.next_tick { start_world worker }
        else
          # worker start failed, never started the world so forget about it
          SUPERVISED_WORLDS.delete @world_id
          BUSY_WORKERS[instance_id] = :not_responding
          EM.next_tick { get_world_running }
        end
    })
  end
  
  def start_world worker
    SUPERVISED_WORLDS[@world_id].worker = worker
    BUSY_WORKERS[worker.instance_id] = :starting_world
    
    info "starting world:#{@world_id} on #{worker.instance_id}"
    EM.defer(proc { 
        begin
          worker.start_world @world_id, @min_heap_size, @max_heap_size
        rescue => e
          error "start world", e
        end
      }, proc {|world|
        if world
          info "world started"
          BUSY_WORKERS.delete worker.instance_id
          SUPERVISED_WORLDS[@world_id].world = world
          SUPERVISED_WORLDS[@world_id].running!
        else
          error "world didn't start"
          # couldn't start world, mark worker as bad
          SUPERVISED_WORLDS.delete @world_id
          BUSY_WORKERS[worker.instance_id] = :not_responding
        end
        EM.next_tick { get_world_running }
    })
  end

end

module Server
  include ProxyLogging
  
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end

  # TODO: Unbind method. If the server on our end goes down, create a shit
  #       storm.
  def unbind
    puts "Disconnection from server"
  end

end

EventMachine.epoll
EventMachine.run do
  include ProxyLogging
  include ProxyAsyncMethods
  include Minefold::Redis

  redis.keys("world:*:connected_players").each {|key| redis.del key}
  redis.del "world:running"
  
  
  puts 'collecting initial state'
  Worker.running.each do |worker|
    if worker.responding?
      worlds = worker.worlds
      worlds.each do |world| 
        SUPERVISED_WORLDS[world.id] = SupervisedWorld.new :running, worker, world
      end
      puts "worker:#{worker.instance_id} uptime_minutes:#{worker.uptime_minutes} worlds:#{worlds.count}"
    else
      puts "worker:#{worker.instance_id} uptime_minutes:#{worker.uptime_minutes} <not responding>"
      BUSY_WORKERS[worker.instance_id] = :not_responding
    end
  end
  
  # listen for minecraft connections
  EventMachine.start_server('0.0.0.0', 25565, Client)
  
  # # listen for http connections
  # EventMachine::start_server("0.0.0.0", 8081, ProxyInfoHandler)
  
  sweep_workers = proc { 
    worker_info = Worker.running.map do |w|
      info = {
        worker:w,
        instance_id:w.instance_id, 
        uptime_minutes:w.uptime_minutes, 
        responding:w.responding?, 
        busy:BUSY_WORKERS[w.instance_id] || "",
        world_info:{}}

      world_count = 0
      worker_player_count = 0
      
      if w.responding?
        world_info = w.worlds.map{|w| {id: w.id, player_count: (CONNECTED_PLAYERS[w.id]||[]).size } }
        
        world_count = world_info.size
        worker_player_count = world_info.inject(0) {|count, world_info| count + world_info[:player_count] }
        
        info[:world_info] = world_info
      end
      
      
      puts "worker:#{info[:instance_id]} uptime_minutes:#{info[:uptime_minutes]} worlds:#{world_count} players:#{worker_player_count} busy:#{info[:busy]} responding:#{info[:responding]}"
      info[:world_count] = world_count
      info[:player_count] = worker_player_count
      info[:world_info].each do |world_info|
        puts "worker:#{info[:instance_id]} world:#{world_info[:id]} players:#{world_info[:player_count]}"
      end
      
      info
    end
  }
  
  fix_swept_workers = proc { |worker_info|
    worker_info.each do |w|
      empty_worlds = w[:world_info].select {|world_info| world_info[:player_count] == 0 }
      
      status = BUSY_WORKERS[w[:instance_id]]

      not_busy = !status
      idle = w[:world_count] == 0
      close_to_end_of_hour = w[:uptime_minutes] % 60 > 55
      needs_fixing = status == :not_responding || (not_busy && !w[:responding] && w[:uptime_minutes] > 5)
      
      if idle && not_busy && close_to_end_of_hour
        puts "Terminating idle worker:#{w[:instance_id]} uptime:#{w[:uptime_minutes]}"
        stop_idle_worker w[:worker]
      elsif needs_fixing
        puts "Diagnosing worker:#{w[:instance_id]}"
        fix_unresponsive_worker w[:instance_id]
      elsif empty_worlds.any? && not_busy
        empty_worlds.each do |world_info| 
          puts "Stopping empty world"
          stop_world world_info[:id]
        end
      end
    end
  }
  
  def stop_idle_worker worker
    return if BUSY_WORKERS[worker.instance_id] && BUSY_WORKERS[worker.instance_id] == :stopping
    
    BUSY_WORKERS[worker.instance_id] = :stopping
    instance_id = worker.instance_id
    EM.defer(proc{
        begin
          worker.stop!
        rescue => e
          puts "Error stopping idle worker\n#{e.message}\n#{e.backtrace}"
        end
      }, proc {
        BUSY_WORKERS.delete instance_id
    })
  end  
  
  def fix_unresponsive_worker instance_id
    return if BUSY_WORKERS[instance_id] && BUSY_WORKERS[instance_id] == :stopping
    
    BUSY_WORKERS[instance_id] = :diagnosing
    EM.defer(proc {
      begin
        worker = Worker.find instance_id
        worker.prepare_for_minefold
        true
      rescue => e
        puts "ERROR: #{[e.inspect, e.backtrace].join("\n")}"
        false
      end
    }, proc { |recovered|
      if recovered
        puts "worker:#{instance_id} back on duty"
        BUSY_WORKERS.delete instance_id 
      else
        puts "couldn't fix worker:#{instance_id}"
        BUSY_WORKERS[instance_id] = :not_responding
      end
    })
  end
  
  the_doctor = EventMachine::PeriodicTimer.new(3 * 60) do 
    puts "Starting worker sweep"
    EM.defer(sweep_workers, fix_swept_workers)
  end

  puts "Starting worker sweep"
  EM.defer(sweep_workers, fix_swept_workers)
  
  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      EventMachine.stop
      puts 'terminated'
    end
  end
  
  EM::PeriodicTimer.new(15) { EM.defer do
      player_count = CONNECTED_PLAYERS.inject(0) {|count, world| count + w.size}
      Statsd.raw 'players.connected', player_count
    end }

  puts "#{ENV['FOLD_ENV']} mode. listening on 0.0.0.0:25565. Creating #{WORKER_INSTANCE_TYPE} workers"
end
