#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'logger'
require 'json'

$:.unshift File.join File.dirname(__FILE__), '../lib'
require 'minefold'

Thread.abort_on_exception = true

# DB = Mongo::Connection.new()['minefold']

CONNECTED_PLAYERS = {}

module Client
  attr_accessor :log

  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
  end

  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      # Lookup username from Mongo
      # @user = DB['users'].find_one(:username => @username)

      # TODO: Untested, mongo may raise an error. Hopefully, instead it
      #       returns nil and the client connected is dropped.
      # TODO: Separate method for dropping a connection rather than unbinding
      #       as logging/stats need to be different.
      # unbind unless @user

      @world_id = 'bigbird' #@user['world_id']

      log.info(:proxy) { "#{@username} connected, sending to #{@world}"}

      keepalive = EventMachine::PeriodicTimer.new(1) do
        send_data [0].pack('C')
      end

      ensure_world_started = proc do
        # find the worker running world
        running_workers = Workers.running
        @worker = running_workers.find do |worker|
          worker.worlds.any? {|world| world.id == @world_id }
        end

        # find an empty worker
        unless @worker
          @worker = running_workers.find do |worker|
            worker.worlds.count == 0
          end
        end

        # otherwise start a new worker
        @worker = Workers.start unless @worker

        @world = @worker.worlds.find {|world| world.id == @world_id } ||
                   @worker.worlds.start(@world_id)
      end

      EventMachine.defer( ensure_world_started, proc { |world|
          host = world.worker.public_ip_address
          @server = EventMachine.connect(host, world.port, Server) do |server|
            server.plexer = self
            log.info(:proxy) { "#{@username} proxied to #{host}:#{world.port}"}
          end
          keepalive.cancel
          @f_connection_established.succeed
          CONNECTED_PLAYERS[@world] ||= []
          CONNECTED_PLAYERS[@world] << @username
          log.info(:proxy) { "#{@world}: #{CONNECTED_PLAYERS[@world].length} player(s)"}

        })

    end

    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access
    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        log.warn(:proxy) { 'unable to connect'}
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end

  def unbind
    log.info(:proxy) { "#{@username} unbound"}
    CONNECTED_PLAYERS[@world_id] ||= []
    CONNECTED_PLAYERS[@world_id].delete @username
    log.info(:proxy) { "#{@world_id}: #{CONNECTED_PLAYERS[@world_id].length} player(s)"}
    if CONNECTED_PLAYERS[@world_id].length == 0
      EventMachine.defer( proc { @worker.stop_world @world_id  }, proc {
        # EventMachine::DeferrableChildProcess.open "#{ROOT}/bin/stop-worker #{@worker.instance_id}"
      })
    end
  end

end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end

  # TODO: Unbind method. If the server on our end goes down, create a shit
  #       storm.

end

EventMachine.run do
  logger = Logger.new(STDOUT)

  EventMachine.start_server('0.0.0.0', 25565, Client) do |connection|
    connection.log = logger
  end

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      EventMachine.stop
      logger.info(:proxy) { 'terminated'}
    end
  end

  logger.info(:proxy) { 'started on 0.0.0.0:25565'}
end
