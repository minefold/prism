#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :proxy

# Graceful shutdown
%w(INT TERM).each {|sig| Signal.trap(sig) { EventMachine.stop}}

module Client
  attr_accessor :db

  def post_init
    @connect = EM::DefaultDeferrable.new
  end

  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      host = @db.get("player.#{username}.host")
      port = @db.get("player.#{username}.port").to_i

      @server = EventMachine.connect(host, port, Server) do |server|
        server.plexer = self
      end

      @connect.succeed
    end

    # If the connection to the server hasn't been made, the client is
    # sending faulty data.
    if @server and !@server.error?
      @server.send data
    else
      close_connection
    end
  end

  def send data
    @connect.callback { send_data data}
  end
end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end
end

EventMachine.run do
  db = Redis.new :host => '0.0.0.0', :port => 6379

  # TODO: Danger, Will Robinson!
  # db.flushall

  # STUB: Overseer
  
  # look up world
  world = 'worldster'
  
  # if the foreman started it should have created an entry for each active server
  server_info = JSON.parse(db.get("servers.#{world}") || '{}')
  
  %w{chrislloyd whatupdave}.each do |player|
    db.set "player.#{player}.host", server_info['ip']
    db.set "player.#{player}.port", server_info['port']
  end
  
  EventMachine.start_server('0.0.0.0', 25565, Client) do |connection|
    connection.db = db
  end
end
