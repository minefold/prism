#!/usr/bin/env ruby
# encoding: UTF-8
require 'bundler/setup'
Bundler.require :default, :proxy
require 'logger'
require 'json'

module SauronHandler
  attr_accessor :future

  def receive_data raw
    response = JSON.parse(raw)
    future.succeed response['host'], response['port']
  end
end

Thread.abort_on_exception = true

module Client
  attr_accessor :db, :log, :sauron_in, :sauron

  def post_init
    @f_connection_established = EM::DefaultDeferrable.new
  end

  def receive_data data
    raw = data.unpack('CN*')
    if raw[0] == 0x02
      # 1 byte for type and 2 bytes for the string length
      raw_offset = 1 + 2

      # Java ecodes strings as UTF-16 and is big-endian by default
      # Way to be different, dude.
      @username = data[raw_offset..-1].
        force_encoding('UTF-16BE').encode('UTF-8')

      log.info(:proxy) { "#{@username} connected"}

      # TODO: Needs to be wrapped in a transaction
      world = @db.get("player.#{@username}.world")

      # Player doesn't belong in a world
      if !world
        close_connection
        logger.warn(:proxy) { "#{@username} kicked, no world"}
      end

      host, port = @db.mget "world.#{world}.host", "world.#{world}.port"

      f_server_info = EM::DefaultDeferrable.new
      f_server_info.callback do |host, port|
        @server = EventMachine.connect(host, port, Server) do |server|
          server.plexer = self
          log.info(:proxy) { "#{@username} proxied to #{host}:#{port}"}
        end
        @f_connection_established.succeed
      end

      # In the case that the world isn't started, for for it from Sauron
      if !host || !port
        sauron.future = f_server_info
        sauron.send_data [:where_art_thou, world].to_json
        # TODO This is needed because of a bug in em-zmq
        EM.next_tick {sauron.notify_readable}
      else
        lock.succeed host, port
      end

    end

    # TODO: We need to check their auth details when they send it over the
    # wire somebody might be spoofing a username to get free access

    @f_connection_established.callback do
      if !@server.error?
        @server.send data
      else
        close_connection
        log.warn(:proxy) { 'unable to connect'}
      end
    end
  end

  def send data
    @f_connection_established.callback { send_data data}
  end

  # It seems like eventmachine is quite slow unbinding the connection. I tried
  # closing it earlier by parsing the 0x255 message but it still exhibited the
  # same behaviour. Strangely, if you cancel loading the world the connection
  # unbinds quicker...
  def unbind
    log.info(:proxy) { "#{@username} unbound"}
  end

end

module Server
  attr_accessor :plexer
  def receive_data data
    plexer.send data
  end

  def send data
    send_data data
  end
end

EventMachine.run do
  logger = Logger.new(STDOUT)
  db = Redis.new :host => '0.0.0.0', :port => 6379
  ctx = EM::ZMQ::Context.new

  sauron = ctx.bind :req, 'ipc:///tmp/proxy-to-sauron', SauronHandler

  EventMachine.start_server('0.0.0.0', 25565, Client) do |connection|
    connection.db = db
    connection.log = logger
    connection.sauron = sauron
  end

  # Graceful shutdown
  %w(INT TERM).each do |sig|
    Signal.trap(sig) do
      EventMachine.stop
      logger.info(:proxy) { 'terminated'}
    end
  end

  logger.info(:proxy) { 'started on 0.0.0.0:25565'}
end
